{
  "language": "Solidity",
  "sources": {
    "contracts/external/maker/interfaces/IDai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDai is IERC20 { // Doesn't conform to IERC2612\n    function nonces(address user) external view returns (uint256);\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/Unwind.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/weth/IWeth.sol\";\nimport \"dss-interfaces/src/dss/VatAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"dss-interfaces/src/dss/GemJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/PotAbstract.sol\";\nimport \"dss-interfaces/src/dss/EndAbstract.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/chai/IChai.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IFYDai.sol\";\nimport \"./interfaces/ILiquidations.sol\";\n\n\n/**\n * @dev Unwind allows everyone to recover their assets from the Yield protocol in the event of a MakerDAO shutdown.\n * During the unwind process, the system debt to MakerDAO is settled first with `settleTreasury`, extracting all free weth.\n * Once the Treasury is settled, any system savings are converted from Chai to Weth using `cashSavings`.\n * At this point, users can settle their positions using `settle`. The MakerDAO rates will be used to convert all debt and collateral to a Weth payout.\n * Users can also redeem here their fyDai for a Weth payout, using `redeem`.\n */\ncontract Unwind is Ownable(), DecimalMath {\n    using SafeMath for uint256;\n\n    bytes32 public constant CHAI = \"CHAI\";\n    bytes32 public constant WETH = \"ETH-A\";\n\n    VatAbstract public vat;\n    DaiAbstract public dai;\n    DaiJoinAbstract public daiJoin;\n    IWeth public weth;\n    GemJoinAbstract public wethJoin;\n    PotAbstract public pot;\n    EndAbstract public end;\n    IChai public chai;\n    ITreasury public treasury;\n    IController public controller;\n    ILiquidations public liquidations;\n\n    uint256 public _fix; // Dai to weth price on DSS Unwind\n    uint256 public _chi; // Chai to dai price on DSS Unwind\n\n    uint256 internal _treasuryWeth; // Weth that was held by treasury before settling\n\n    bool public settled;\n    bool public cashedOut;\n    bool public live = true;\n\n    /// @dev The constructor links to vat, daiJoin, weth, wethJoin, jug, pot, end, chai, treasury, controller and liquidations.\n    /// Liquidations should have privileged access to controller and liquidations using orchestration.\n    /// The constructor gives treasury and end permission on unwind's MakerDAO vaults.\n    constructor (\n        address end_,\n        address liquidations_\n    ) public {\n        end = EndAbstract(end_);\n        liquidations = ILiquidations(liquidations_);\n        controller = liquidations.controller();\n        treasury = controller.treasury();\n        vat = treasury.vat();\n        dai = treasury.dai();\n        daiJoin = treasury.daiJoin();\n        weth = treasury.weth();\n        wethJoin = treasury.wethJoin();\n        pot = treasury.pot();\n        chai = treasury.chai();\n\n        treasury.dai().approve(address(daiJoin), uint256(-1));\n        vat.hope(address(treasury));\n        vat.hope(address(end));\n    }\n\n    /// @dev max(0, x - y)\n    function subFloorZero(uint256 x, uint256 y) public pure returns(uint256) {\n        if (y >= x) return 0;\n        else return x - y;\n    }\n\n    /// @dev Safe casting from uint256 to int256\n    function toInt(uint256 x) internal pure returns(int256) {\n        require(\n            x <= uint256(type(int256).max),\n            \"Treasury: Cast overflow\"\n        );\n        return int256(x);\n    }\n\n    /// @dev Disables treasury, controller and liquidations.\n    function unwind() public {\n        require(\n            end.tag(WETH) != 0,\n            \"Unwind: MakerDAO not shutting down\"\n        );\n        live = false;\n        treasury.shutdown();\n        controller.shutdown();\n        liquidations.shutdown();\n    }\n\n    /// @dev Return the Dai equivalent value to a Chai amount.\n    /// @param chaiAmount The Chai value to convert.\n    /// @param chi The `chi` value from `Pot`.\n    function chaiToDai(uint256 chaiAmount, uint256 chi) public pure returns(uint256) {\n        return muld(chaiAmount, chi);\n    }\n\n    /// @dev Return the Weth equivalent value to a Dai amount, during Dss Shutdown\n    /// @param daiAmount The Dai value to convert.\n    /// @param fix The `fix` value from `End`.\n    function daiToFixWeth(uint256 daiAmount, uint256 fix) public pure returns(uint256) {\n        return muld(daiAmount, fix);\n    }\n\n    /// @dev Settle system debt in MakerDAO and free remaining collateral.\n    function settleTreasury() public {\n        require(\n            live == false,\n            \"Unwind: Unwind first\"\n        );\n        (uint256 ink, uint256 art) = vat.urns(WETH, address(treasury));\n        require(ink > 0, \"Unwind: Nothing to settle\");\n\n        _treasuryWeth = ink;                            // We will need this to skim profits\n        vat.fork(                                      // Take the treasury vault\n            WETH,\n            address(treasury),\n            address(this),\n            toInt(ink),\n            toInt(art)\n        );\n        end.skim(WETH, address(this));                // Settle debts\n        end.free(WETH);                               // Free collateral\n        uint256 gem = vat.gem(WETH, address(this));   // Find out how much collateral we have now\n        wethJoin.exit(address(this), gem);            // Take collateral out\n        settled = true;\n    }\n\n    /// @dev Put all chai savings in MakerDAO and exchange them for weth\n    function cashSavings() public {\n        require(\n            end.tag(WETH) != 0,\n            \"Unwind: End.sol not caged\"\n        );\n        require(\n            end.fix(WETH) != 0,\n            \"Unwind: End.sol not ready\"\n        );\n        \n        uint256 chaiTokens = chai.balanceOf(address(treasury));\n        require(chaiTokens > 0, \"Unwind: Nothing to cash\");\n        chai.exit(address(treasury), chaiTokens);           // Get the chai as dai\n\n        uint256 daiTokens = dai.balanceOf(address(this));   // Find out how much is the chai worth\n        daiJoin.join(address(this), daiTokens);             // Put the dai into MakerDAO\n        end.pack(daiTokens);                                // Into End.sol, more exactly\n        end.cash(WETH, daiTokens);                          // Exchange the dai for weth\n        uint256 gem = vat.gem(WETH, address(this));         // Find out how much collateral we have now\n        wethJoin.exit(address(this), gem);                  // Take collateral out\n        cashedOut = true;\n\n        _fix = end.fix(WETH);\n        _chi = pot.chi();\n    }\n\n    /// @dev Settles a series position in Controller for any user, and then returns any remaining collateral as weth using the unwind Dai to Weth price.\n    /// @param collateral Valid collateral type.\n    /// @param user User vault to settle, and wallet to receive the corresponding weth.\n    function settle(bytes32 collateral, address user) public {\n        (uint256 tokens, uint256 debt) = controller.erase(collateral, user);\n        require(tokens > 0, \"Unwind: Nothing to settle\");\n\n        uint256 remainder;\n        if (collateral == WETH) {\n            remainder = subFloorZero(tokens, daiToFixWeth(debt, _fix));\n        } else if (collateral == CHAI) {\n            remainder = daiToFixWeth(subFloorZero(chaiToDai(tokens, _chi), debt), _fix);\n        }\n        require(weth.transfer(user, remainder));\n    }\n\n    /// @dev Settles a user vault in Liquidations, and then returns any remaining collateral as weth using the unwind Dai to Weth price.\n    /// @param user User vault to settle, and wallet to receive the corresponding weth.\n    function settleLiquidations(address user) public {\n        (uint256 wethAmount, uint256 debt) = liquidations.erase(user);\n        require(wethAmount > 0, \"Unwind: Nothing to settle\");\n\n        uint256 remainder = subFloorZero(wethAmount, daiToFixWeth(debt, _fix));\n\n        require(weth.transfer(user, remainder));\n    }\n\n    /// @dev Redeems FYDai for weth for any user. FYDai.redeem won't work if MakerDAO is in shutdown.\n    /// @param maturity Maturity of an added series\n    /// @param user Wallet containing the fyDai to burn.\n    function redeem(uint256 maturity, address user) public {\n        IFYDai fyDai = controller.series(maturity);\n        require(fyDai.unlocked() == 1, \"fyDai is still locked\");\n        uint256 fyDaiAmount = fyDai.balanceOf(user);\n        require(fyDaiAmount > 0, \"Unwind: Nothing to redeem\");\n\n        fyDai.burn(user, fyDaiAmount);\n        require(\n            weth.transfer(\n                user,\n                daiToFixWeth(muld(fyDaiAmount, fyDai.chiGrowth()), _fix)\n            )\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@yield-protocol/utils/contracts/math/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\n/// @dev Implements simple fixed point math mul and div operations for 27 decimals.\ncontract DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 constant public UNIT = 1e27;\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with 27 digits.\n    function muld(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.mul(y).div(UNIT);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with 27 digits.\n    function divd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x.mul(UNIT).div(y);\n    }\n\n    /// @dev Multiplies x and y, rounding up to the closest representable number.\n    /// Assumes x and y are both fixed point with `decimals` digits.\n    function muldrup(uint256 x, uint256 y) internal pure returns (uint256)\n    {\n        uint256 z = x.mul(y);\n        return z.mod(UNIT) == 0 ? z.div(UNIT) : z.div(UNIT).add(1);\n    }\n\n    /// @dev Divides x between y, rounding up to the closest representable number.\n    /// Assumes x and y are both fixed point with `decimals` digits.\n    function divdrup(uint256 x, uint256 y) internal pure returns (uint256)\n    {\n        uint256 z = x.mul(UNIT);\n        return z.mod(y) == 0 ? z.div(y) : z.div(y).add(1);\n    }\n}\n"
    },
    "@yield-protocol/utils/contracts/interfaces/weth/IWeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint) external;\n}"
    },
    "dss-interfaces/src/dss/VatAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/vat.sol\ninterface VatAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function can(address, address) external view returns (uint256);\n    function hope(address) external;\n    function nope(address) external;\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function urns(bytes32, address) external view returns (uint256, uint256);\n    function gem(bytes32, address) external view returns (uint256);\n    function dai(address) external view returns (uint256);\n    function sin(address) external view returns (uint256);\n    function debt() external view returns (uint256);\n    function vice() external view returns (uint256);\n    function Line() external view returns (uint256);\n    function live() external view returns (uint256);\n    function init(bytes32) external;\n    function file(bytes32, uint256) external;\n    function file(bytes32, bytes32, uint256) external;\n    function cage() external;\n    function slip(bytes32, address, int256) external;\n    function flux(bytes32, address, address, uint256) external;\n    function move(address, address, uint256) external;\n    function frob(bytes32, address, address, address, int256, int256) external;\n    function fork(bytes32, address, address, int256, int256) external;\n    function grab(bytes32, address, address, address, int256, int256) external;\n    function heal(uint256) external;\n    function suck(address, address, uint256) external;\n    function fold(bytes32, address, int256) external;\n}\n"
    },
    "dss-interfaces/src/dss/DaiAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/dai.sol\ninterface DaiAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function version() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n    function nonces(address) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function transfer(address, uint256) external;\n    function transferFrom(address, address, uint256) external returns (bool);\n    function mint(address, uint256) external;\n    function burn(address, uint256) external;\n    function approve(address, uint256) external returns (bool);\n    function push(address, uint256) external;\n    function pull(address, uint256) external;\n    function move(address, address, uint256) external;\n    function permit(address, address, uint256, uint256, bool, uint8, bytes32, bytes32) external;\n}\n"
    },
    "dss-interfaces/src/dss/GemJoinAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/join.sol\ninterface GemJoinAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function vat() external view returns (address);\n    function ilk() external view returns (bytes32);\n    function gem() external view returns (address);\n    function dec() external view returns (uint256);\n    function live() external view returns (uint256);\n    function cage() external;\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n"
    },
    "dss-interfaces/src/dss/DaiJoinAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/join.sol\ninterface DaiJoinAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address usr) external;\n    function deny(address usr) external;\n    function vat() external view returns (address);\n    function dai() external view returns (address);\n    function live() external view returns (uint256);\n    function cage() external;\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n"
    },
    "dss-interfaces/src/dss/PotAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/pot.sol\ninterface PotAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function pie(address) external view returns (uint256);\n    function Pie() external view returns (uint256);\n    function dsr() external view returns (uint256);\n    function chi() external view returns (uint256);\n    function vat() external view returns (address);\n    function vow() external view returns (address);\n    function rho() external view returns (uint256);\n    function live() external view returns (uint256);\n    function file(bytes32, uint256) external;\n    function file(bytes32, address) external;\n    function cage() external;\n    function drip() external returns (uint256);\n    function join(uint256) external;\n    function exit(uint256) external;\n}\n"
    },
    "dss-interfaces/src/dss/EndAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/end.sol\ninterface EndAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function vat() external view returns (address);\n    function cat() external view returns (address);\n    function vow() external view returns (address);\n    function pot() external view returns (address);\n    function spot() external view returns (address);\n    function live() external view returns (uint256);\n    function when() external view returns (uint256);\n    function wait() external view returns (uint256);\n    function debt() external view returns (uint256);\n    function tag(bytes32) external view returns (uint256);\n    function gap(bytes32) external view returns (uint256);\n    function Art(bytes32) external view returns (uint256);\n    function fix(bytes32) external view returns (uint256);\n    function bag(address) external view returns (uint256);\n    function out(bytes32, address) external view returns (uint256);\n    function WAD() external view returns (uint256);\n    function RAY() external view returns (uint256);\n    function file(bytes32, address) external;\n    function file(bytes32, uint256) external;\n    function cage() external;\n    function cage(bytes32) external;\n    function skip(bytes32, uint256) external;\n    function skim(bytes32, address) external;\n    function free(bytes32) external;\n    function thaw() external;\n    function flow(bytes32) external;\n    function pack(uint256) external;\n    function cash(bytes32, uint256) external;\n}\n"
    },
    "@yield-protocol/utils/contracts/interfaces/chai/IChai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../IERC2612.sol\";\n\n/// @dev interface for the chai contract\n/// Taken from https://github.com/makerdao/developerguides/blob/master/dai/dsr-integration-guide/dsr.sol\ninterface IChai is IERC20, IERC2612 {\n    function move(address src, address dst, uint wad) external returns (bool);\n    function dai(address usr) external returns (uint wad);\n    function join(address dst, uint wad) external;\n    function exit(address src, uint wad) external;\n    function draw(address src, uint wad) external;\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/interfaces/ITreasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@yield-protocol/utils/contracts/interfaces/weth/IWeth.sol\";\nimport { VatAbstract } from \"dss-interfaces/src/dss/VatAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"dss-interfaces/src/dss/GemJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/PotAbstract.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/chai/IChai.sol\";\n\ninterface ITreasury {\n    function debt() external view returns(uint256);\n    function savings() external view returns(uint256);\n    function pushDai(address user, uint256 dai) external;\n    function pullDai(address user, uint256 dai) external;\n    function pushChai(address user, uint256 chai) external;\n    function pullChai(address user, uint256 chai) external;\n    function pushWeth(address to, uint256 weth) external;\n    function pullWeth(address to, uint256 weth) external;\n    function shutdown() external;\n    function live() external view returns(bool);\n\n    function vat() external view returns (VatAbstract);\n    function weth() external view returns (IWeth);\n    function dai() external view returns (DaiAbstract);\n    function daiJoin() external view returns (DaiJoinAbstract);\n    function wethJoin() external view returns (GemJoinAbstract);\n    function pot() external view returns (PotAbstract);\n    function chai() external view returns (IChai);\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@yield-protocol/utils/contracts/interfaces/IDelegable.sol\";\nimport \"./ITreasury.sol\";\nimport \"./IFYDai.sol\";\n\n\ninterface IController is IDelegable {\n    function treasury() external view returns (ITreasury);\n    function series(uint256) external view returns (IFYDai);\n    function seriesIterator(uint256) external view returns (uint256);\n    function totalSeries() external view returns (uint256);\n    function containsSeries(uint256) external view returns (bool);\n    function posted(bytes32, address) external view returns (uint256);\n    function locked(bytes32, address) external view returns (uint256);\n    function debtFYDai(bytes32, uint256, address) external view returns (uint256);\n    function debtDai(bytes32, uint256, address) external view returns (uint256);\n    function totalDebtDai(bytes32, address) external view returns (uint256);\n    function isCollateralized(bytes32, address) external view returns (bool);\n    function inDai(bytes32, uint256, uint256) external view returns (uint256);\n    function inFYDai(bytes32, uint256, uint256) external view returns (uint256);\n    function erase(bytes32, address) external returns (uint256, uint256);\n    function shutdown() external;\n    function post(bytes32, address, address, uint256) external;\n    function withdraw(bytes32, address, address, uint256) external;\n    function borrow(bytes32, uint256, address, address, uint256) external;\n    function repayFYDai(bytes32, uint256, address, address, uint256) external returns (uint256);\n    function repayDai(bytes32, uint256, address, address, uint256) external returns (uint256);\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/interfaces/IFYDai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/IERC2612.sol\";\n\ninterface IFYDai is IERC20, IERC2612 {\n    function isMature() external view returns(bool);\n    function maturity() external view returns(uint);\n    function chi0() external view returns(uint);\n    function rate0() external view returns(uint);\n    function chiGrowth() external view returns(uint);\n    function rateGrowth() external view returns(uint);\n    function mature() external;\n    function unlocked() external view returns (uint);\n    function mint(address, uint) external;\n    function burn(address, uint) external;\n    function flashMint(uint, bytes calldata) external;\n    function redeem(address, address, uint256) external returns (uint256);\n    // function transfer(address, uint) external returns (bool);\n    // function transferFrom(address, address, uint) external returns (bool);\n    // function approve(address, uint) external returns (bool);\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/interfaces/ILiquidations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"./IController.sol\";\n\n\ninterface ILiquidations {\n    function shutdown() external;\n    function totals() external view returns(uint128, uint128);\n    function erase(address) external returns(uint128, uint128);\n\n    function controller() external returns(IController);\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@yield-protocol/utils/contracts/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "@yield-protocol/utils/contracts/interfaces/IDelegable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\n\ninterface IDelegable {\n    function addDelegate(address) external;\n    function addDelegateBySignature(address, address, uint, uint8, bytes32, bytes32) external;\n    function delegated(address, address) external view returns (bool);\n}\n"
    },
    "contracts/USDCProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\"; // TODO: Bring into @yield-protocol/utils\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\"; // TODO: Make into library\nimport \"@yield-protocol/utils/contracts/utils/SafeCast.sol\";\nimport \"@yield-protocol/utils/contracts/utils/YieldAuth.sol\";\nimport \"@yield-protocol/vault-v1/contracts/interfaces/IFYDai.sol\";\nimport \"@yield-protocol/vault-v1/contracts/interfaces/ITreasury.sol\";\nimport \"@yield-protocol/vault-v1/contracts/interfaces/IController.sol\";\nimport \"@yield-protocol/yieldspace-v1/contracts/interfaces/IPool.sol\";\nimport \"dss-interfaces/src/dss/AuthGemJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"./interfaces/IUSDC.sol\";\nimport \"./interfaces/DssPsmAbstract.sol\";\n\n\nlibrary RoundingMath {\n    function divrup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require (y > 0, \"USDCProxy: Division by zero\");\n        return x % y == 0 ? x / y : x / y + 1;\n    }\n}\n\ncontract USDCProxy is DecimalMath {\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n    using RoundingMath for uint256;\n    using YieldAuth for DaiAbstract;\n    using YieldAuth for IFYDai;\n    using YieldAuth for IUSDC;\n    using YieldAuth for IController;\n    using YieldAuth for IPool;\n\n    DaiAbstract public immutable dai;\n    IUSDC public immutable usdc;\n    IController public immutable controller;\n    DssPsmAbstract public immutable psm;\n\n    address public immutable treasury;\n\n    bytes32 public constant WETH = \"ETH-A\";\n\n    constructor(IController _controller, DssPsmAbstract psm_) public {\n        ITreasury _treasury = _controller.treasury();\n        dai = _treasury.dai();\n        treasury = address(_treasury);\n        controller = _controller;\n        psm = psm_;\n        usdc = IUSDC(AuthGemJoinAbstract(psm_.gemJoin()).gem());\n    }\n\n    /// @dev Borrow fyDai from Controller, sell it immediately for Dai in a pool, and sell the Dai for USDC in Maker's PSM, for a maximum fyDai debt.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `borrowDaiForMaximumFYDaiWithSignature`.\n    /// Caller must have called `borrowDaiForMaximumFYDaiWithSignature` at least once before to set proxy approvals.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Wallet to send the resulting Dai to.\n    /// @param usdcToBorrow Exact amount of USDC that should be obtained.\n    /// @param maximumFYDai Maximum amount of FYDai to borrow.\n    function borrowUSDCForMaximumFYDai(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 usdcToBorrow,\n        uint256 maximumFYDai\n    )\n        public\n        returns (uint256)\n    {\n        pool.fyDai().approve(address(pool), type(uint256).max); // TODO: Move to right place\n        \n        uint256 usdcToBorrow18 = usdcToBorrow.mul(1e12); // USDC has 6 decimals\n        uint256 fee = usdcToBorrow18.mul(psm.tout()) / 1e18; // tout has 18 decimals\n        uint256 daiToBuy = usdcToBorrow18.add(fee);\n\n        uint256 fyDaiToBorrow = pool.buyDaiPreview(daiToBuy.toUint128()); // If not calculated on-chain, there will be fyDai left as slippage\n        require (fyDaiToBorrow <= maximumFYDai, \"USDCProxy: Too much fyDai required\");\n\n        // The collateral for this borrow needs to have been posted beforehand\n        controller.borrow(collateral, maturity, msg.sender, address(this), fyDaiToBorrow);\n        pool.buyDai(address(this), address(this), daiToBuy.toUint128());\n        psm.buyGem(to, usdcToBorrow); // PSM takes USDC amounts with 6 decimals\n\n        return fyDaiToBorrow;\n    }\n\n    /// @dev Repay an amount of fyDai debt in Controller using a given amount of USDC exchanged Dai in Maker's PSM, and then for fyDai at pool rates, with a minimum of fyDai debt required to be paid.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `repayMinimumFYDaiDebtForDaiWithSignature`.\n    /// Must have approved the operator with `pool.addDelegate(borrowProxy.address)` or with `repayMinimumFYDaiDebtForDaiWithSignature`.\n    /// If `repaymentInUSDC` exceeds the existing debt, the surplus will be locked in the proxy.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param usdcRepayment Exact amount of USDC that should be spent on the repayment.\n    /// @param minFYDaiRepayment Minimum amount of fyDai debt to repay.\n    function repayDebtEarly(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 usdcRepayment,\n        uint256 minFYDaiRepayment\n    )\n        public\n        returns (uint256)\n    {\n        uint256 usdcRepayment18 = usdcRepayment.mul(1e12); // USDC has 6 decimals\n        uint256 fee = usdcRepayment18.mul(psm.tin()) / 1e18; // Fees in PSM are fixed point in WAD\n        uint256 daiObtained = usdcRepayment18.sub(fee); // If not right, the `sellDai` might revert.\n\n        usdc.transferFrom(msg.sender, address(this), usdcRepayment);\n        psm.sellGem(address(this), usdcRepayment); // PSM takes USDC amounts with 6 decimals\n        uint256 fyDaiRepayment =  pool.sellDai(address(this), address(this), daiObtained.toUint128());\n        require(fyDaiRepayment >= minFYDaiRepayment, \"USDCProxy: Not enough debt repaid\");\n        controller.repayFYDai(collateral, maturity, address(this), to, fyDaiRepayment);\n\n        return daiObtained;\n    }\n\n    /// @dev Repay all debt in Controller using for a maximum amount of USDC, reverting if surpassed.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// Must have approved the operator with `pool.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param maxUSDCIn Maximum amount of USDC that should be spent on the repayment.\n    function repayAllEarly(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 maxUSDCIn\n    )\n        public\n        returns (uint256)\n    {\n        uint256 fyDaiDebt = controller.debtFYDai(collateral, maturity, to);\n        uint256 daiIn = pool.buyFYDaiPreview(fyDaiDebt.toUint128());\n        uint256 usdcIn18 = (daiIn * 1e18).divrup(1e18 + psm.tin()); // Fixed point division with 18 decimals - We are working an usdc value from a dai one, so we round up.\n        uint256 usdcIn = usdcIn18.divrup(1e12); // We are working an usdc value from a dai one, so we round up.\n\n        require (usdcIn <= maxUSDCIn, \"USDCProxy: Too much USDC required\");\n        usdc.transferFrom(msg.sender, address(this), usdcIn);\n        psm.sellGem(address(this), usdcIn);\n        pool.buyFYDai(address(this), address(this), fyDaiDebt.toUint128());\n        controller.repayFYDai(collateral, maturity, address(this), to, fyDaiDebt);\n\n        return usdcIn;\n    }\n\n    /// @dev Repay an exact amount of Dai-denominated debt in Controller using USDC.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// Must have approved the operator with `pool.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param daiRepayment Amount of Dai that should be bought from the PSM for the repayment.\n    /// @return Amount of USDC that was taken from the user for the repayment.\n    function repayDebtMature(\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 daiRepayment\n    )\n        public\n        returns (uint256)\n    {\n        return _repayDebtMature(\n            collateral,\n            maturity,\n            to,\n            daiRepayment\n        );\n    }\n\n    /// @dev Repay all debt for an user and series in Controller using USDC.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// Must have approved the operator with `pool.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @return Amount of USDC that was taken from the user for the repayment.\n    function repayAllMature(\n        bytes32 collateral,\n        uint256 maturity,\n        address to\n    )\n        public\n        returns (uint256)\n    {\n        return _repayDebtMature(\n            collateral,\n            maturity,\n            to,\n            controller.debtDai(collateral, maturity, msg.sender)\n        );\n    }\n\n    /// @dev Repay an exact amount of Dai-denominated debt in Controller using USDC.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// Must have approved the operator with `pool.addDelegate(borrowProxy.address)` or with `repayAllWithFYDaiWithSignature`.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @return Amount of USDC that was taken from the user for the repayment.\n    function _repayDebtMature(\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 daiRepayment\n    )\n        internal\n        returns (uint256)\n    {\n        uint256 usdcRepayment18 = (daiRepayment * 1e18).divrup(1e18 - psm.tin());\n        uint256 usdcRepayment = usdcRepayment18.divrup(1e12);\n        usdc.transferFrom(msg.sender, address(this), usdcRepayment);\n        psm.sellGem(address(this), usdcRepayment);\n        controller.repayDai(collateral, maturity, address(this), to, daiRepayment);\n\n        return usdcRepayment;\n    }\n\n    /// --------------------------------------------------\n    /// Signature method wrappers\n    /// --------------------------------------------------\n\n    /// @dev Set proxy approvals for `borrowUSDCForMaximumFYDai` with a given pool.\n    function borrowUSDCForMaximumFYDaiApprove(IPool pool) public {\n        // allow the pool to pull FYDai/dai from us for trading\n        if (pool.fyDai().allowance(address(this), address(pool)) < type(uint112).max)\n            pool.fyDai().approve(address(pool), type(uint256).max);\n        \n        if (dai.allowance(address(this), address(psm)) < type(uint256).max)\n            dai.approve(address(psm), type(uint256).max); // Approve to provide Dai to the PSM\n    }\n\n    /// @dev Borrow fyDai from Controller, sell it immediately for Dai in a pool, and sell the Dai for USDC in Maker's PSM, for a maximum fyDai debt.\n    /// Must have approved the operator with `controller.addDelegate(borrowProxy.address)` or with `borrowDaiForMaximumFYDaiWithSignature`.\n    /// Caller must have called `borrowDaiForMaximumFYDaiWithSignature` at least once before to set proxy approvals.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Wallet to send the resulting Dai to.\n    /// @param usdcToBorrow Exact amount of USDC that should be obtained.\n    /// @param maximumFYDai Maximum amount of FYDai to borrow.\n    /// @param controllerSig packed signature for delegation of this proxy in the controller. Ignored if '0x'.\n    function borrowUSDCForMaximumFYDaiWithSignature(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 usdcToBorrow,\n        uint256 maximumFYDai,\n        \n        bytes memory controllerSig\n    )\n        public\n        returns (uint256)\n    {\n        borrowUSDCForMaximumFYDaiApprove(pool);\n        if (controllerSig.length > 0) controller.addDelegatePacked(controllerSig);\n        return borrowUSDCForMaximumFYDai(pool, collateral, maturity, to, usdcToBorrow, maximumFYDai);\n    }\n\n    /// @dev Set proxy approvals for `repayDebtEarly` with a given pool.\n    function repayDebtEarlyApprove(IPool pool) public {\n        // Send the USDC to the PSM\n        if (usdc.allowance(address(this), address(psm.gemJoin())) < type(uint112).max) // USDC reduces allowances when set to MAX\n            usdc.approve(address(psm.gemJoin()), type(uint256).max);\n        \n        // Send the Dai to the Pool\n        if (dai.allowance(address(this), address(pool)) < type(uint256).max)\n            dai.approve(address(pool), type(uint256).max);\n\n        // Send the fyDai to the Treasury\n        if (pool.fyDai().allowance(address(this), treasury) < type(uint112).max)\n            pool.fyDai().approve(treasury, type(uint256).max);\n    }\n\n    /// @dev Repay an amount of fyDai debt in Controller using a given amount of USDC exchanged Dai in Maker's PSM, and then for fyDai at pool rates, with a minimum of fyDai debt required to be paid.\n    /// If `repaymentInDai` exceeds the existing debt, only the necessary Dai will be used.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param fyDaiDebt Amount of fyDai debt to repay.\n    /// @param repaymentInUSDC Exact amount of USDC that should be spent on the repayment.\n    /// @param usdcSig packed signature for permit of USDC transfers to this proxy. Ignored if '0x'.\n    /// @param controllerSig packed signature for delegation of this proxy in the controller. Ignored if '0x'.\n    function repayDebtEarlyWithSignature(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 repaymentInUSDC,\n        uint256 fyDaiDebt, // Calculate off-chain, works as slippage protection\n        bytes memory usdcSig,\n        bytes memory controllerSig\n    )\n        public\n        returns (uint256)\n    {\n        repayDebtEarlyApprove(pool);\n        if (usdcSig.length > 0) usdc.permitPacked(address(this), usdcSig);\n        if (controllerSig.length > 0) controller.addDelegatePacked(controllerSig);\n        return repayDebtEarly(pool, collateral, maturity, to, repaymentInUSDC, fyDaiDebt);\n    }\n\n    /// @dev Repay all debt in Controller using for a maximum amount of USDC, reverting if surpassed.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param maxUSDCIn Maximum amount of USDC that should be spent on the repayment.\n    /// @param usdcSig packed signature for permit of USDC transfers to this proxy. Ignored if '0x'.\n    /// @param controllerSig packed signature for delegation of this proxy in the controller. Ignored if '0x'.\n    function repayAllEarlyWithSignature(\n        IPool pool,\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 maxUSDCIn,\n        bytes memory usdcSig,\n        bytes memory controllerSig\n    )\n        public\n        returns (uint256)\n    {\n        repayDebtEarlyApprove(pool); // Same permissions\n        if (usdcSig.length > 0) usdc.permitPacked(address(this), usdcSig);\n        if (controllerSig.length > 0) controller.addDelegatePacked(controllerSig);\n        return repayAllEarly(pool, collateral, maturity, to, maxUSDCIn);\n    }\n\n    /// @dev Set proxy approvals for `repayDebtMature`\n    function repayDebtMatureApprove() public {\n        // Send the USDC to the PSM\n        if (usdc.allowance(address(this), address(psm.gemJoin())) < type(uint112).max) // USDC reduces allowances when set to MAX\n            usdc.approve(address(psm.gemJoin()), type(uint256).max);\n        \n        // Send the Dai to the Treasury\n        if (dai.allowance(address(this), address(treasury)) < type(uint256).max)\n            dai.approve(address(treasury), type(uint256).max);\n    }\n\n    /// @dev Repay an amount of fyDai debt in Controller using a given amount of USDC exchanged Dai in Maker's PSM.\n    /// If the amount of Dai obtained by selling USDC exceeds the existing debt, the surplus will be locked in the proxy.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param repaymentInUSDC Exact amount of USDC that should be spent on the repayment.\n    /// @param usdcSig packed signature for permit of USDC transfers to this proxy. Ignored if '0x'.\n    /// @param controllerSig packed signature for delegation of this proxy in the controller. Ignored if '0x'.\n    function repayDebtMatureWithSignature(\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        uint256 repaymentInUSDC,\n        bytes memory usdcSig,\n        bytes memory controllerSig\n    )\n        public\n        returns (uint256)\n    {\n        repayDebtMatureApprove();\n        if (usdcSig.length > 0) usdc.permitPacked(address(this), usdcSig);\n        if (controllerSig.length > 0) controller.addDelegatePacked(controllerSig);\n        return repayDebtMature(collateral, maturity, to, repaymentInUSDC);\n    }\n\n    /// @dev Repay all debt for an user in Controller for a mature series using Maker's PSM.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param to Yield Vault to repay fyDai debt for.\n    /// @param usdcSig packed signature for permit of USDC transfers to this proxy. Ignored if '0x'.\n    /// @param controllerSig packed signature for delegation of this proxy in the controller. Ignored if '0x'.\n    function repayAllMatureWithSignature(\n        bytes32 collateral,\n        uint256 maturity,\n        address to,\n        bytes memory usdcSig,\n        bytes memory controllerSig\n    )\n        public\n        returns (uint256)\n    {\n        repayDebtMatureApprove(); // Same permissions\n        if (usdcSig.length > 0) usdc.permitPacked(address(this), usdcSig);\n        if (controllerSig.length > 0) controller.addDelegatePacked(controllerSig);\n        return repayAllMature(collateral, maturity, to);\n    }\n\n    /// --------------------------------------------------\n    /// Convenience functions\n    /// --------------------------------------------------\n\n    /// @dev Return PSM's tin, so the frontend needs to do one less call.\n    function tin() public view returns (uint256) {\n        return psm.tin();\n    }\n\n    /// @dev Return PSM's tout, so the frontend needs to do one less call.\n    function tout() public view returns (uint256) {\n        return psm.tout();\n    }\n}"
    },
    "@yield-protocol/utils/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\n\nlibrary SafeCast {\n    /// @dev Safe casting from uint256 to uint128\n    function toUint128(uint256 x) internal pure returns(uint128) {\n        require(\n            x <= type(uint128).max,\n            \"SafeCast: Cast overflow\"\n        );\n        return uint128(x);\n    }\n\n    /// @dev Safe casting from uint256 to int256\n    function toInt256(uint256 x) internal pure returns(int256) {\n        require(\n            x <= uint256(type(int256).max),\n            \"SafeCast: Cast overflow\"\n        );\n        return int256(x);\n    }\n}"
    },
    "@yield-protocol/utils/contracts/utils/YieldAuth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"../interfaces/IERC2612.sol\";\nimport \"../interfaces/IDelegable.sol\";\n\n/// @dev This library encapsulates methods obtain authorizations using packed signatures\nlibrary YieldAuth {\n\n    /// @dev Unpack r, s and v from a `bytes` signature.\n    /// @param signature A packed signature.\n    function unpack(bytes memory signature) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n    }\n\n    /// @dev Use a packed `signature` to add this contract as a delegate of caller on the `target` contract.\n    /// @param target The contract to add delegation to.\n    /// @param signature A packed signature.\n    function addDelegatePacked(IDelegable target, bytes memory signature) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        (r, s, v) = unpack(signature);\n        target.addDelegateBySignature(msg.sender, address(this), type(uint256).max, v, r, s);\n    }\n\n    /// @dev Use a packed `signature` to add this contract as a delegate of caller on the `target` contract.\n    /// @param target The contract to add delegation to.\n    /// @param user The user delegating access.\n    /// @param delegate The address obtaining access.\n    /// @param signature A packed signature.\n    function addDelegatePacked(IDelegable target, address user, address delegate, bytes memory signature) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        (r, s, v) = unpack(signature);\n        target.addDelegateBySignature(user, delegate, type(uint256).max, v, r, s);\n    }\n\n    /// @dev Use a packed `signature` to approve `spender` on the `dai` contract for the maximum amount.\n    /// @param dai The Dai contract to add delegation to.\n    /// @param spender The address obtaining an approval.\n    /// @param signature A packed signature.\n    function permitPackedDai(DaiAbstract dai, address spender, bytes memory signature) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        (r, s, v) = unpack(signature);\n        dai.permit(msg.sender, spender, dai.nonces(msg.sender), type(uint256).max, true, v, r, s);\n    }\n\n    /// @dev Use a packed `signature` to approve `spender` on the target IERC2612 `token` contract for the maximum amount.\n    /// @param token The contract to add delegation to.\n    /// @param spender The address obtaining an approval.\n    /// @param signature A packed signature.\n    function permitPacked(IERC2612 token, address spender, bytes memory signature) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        (r, s, v) = unpack(signature);\n        token.permit(msg.sender, spender, type(uint256).max, type(uint256).max, v, r, s);\n    }\n}"
    },
    "@yield-protocol/yieldspace-v1/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/IDelegable.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/IERC2612.sol\";\nimport \"@yield-protocol/vault-v1/contracts/interfaces/IFYDai.sol\";\n\n\ninterface IPool is IDelegable, IERC20, IERC2612 {\n    function dai() external view returns(IERC20);\n    function fyDai() external view returns(IFYDai);\n    function getDaiReserves() external view returns(uint128);\n    function getFYDaiReserves() external view returns(uint128);\n    function sellDai(address from, address to, uint128 daiIn) external returns(uint128);\n    function buyDai(address from, address to, uint128 daiOut) external returns(uint128);\n    function sellFYDai(address from, address to, uint128 fyDaiIn) external returns(uint128);\n    function buyFYDai(address from, address to, uint128 fyDaiOut) external returns(uint128);\n    function sellDaiPreview(uint128 daiIn) external view returns(uint128);\n    function buyDaiPreview(uint128 daiOut) external view returns(uint128);\n    function sellFYDaiPreview(uint128 fyDaiIn) external view returns(uint128);\n    function buyFYDaiPreview(uint128 fyDaiOut) external view returns(uint128);\n    function mint(address from, address to, uint256 daiOffered) external returns (uint256);\n    function burn(address from, address to, uint256 tokensBurned) external returns (uint256, uint256);\n}"
    },
    "dss-interfaces/src/dss/AuthGemJoinAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss-deploy/blob/master/src/join.sol\ninterface AuthGemJoinAbstract {\n    function vat() external view returns (address);\n    function ilk() external view returns (bytes32);\n    function gem() external view returns (address);\n    function dec() external view returns (uint256);\n    function live() external view returns (uint256);\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function cage() external;\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n}\n"
    },
    "contracts/interfaces/IUSDC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/IERC2612.sol\";\n\n\ninterface IUSDC is IERC20, IERC2612 { \n    function PERMIT_TYPEHASH() external view returns(bytes32);\n    function DOMAIN_SEPARATOR() external view returns(bytes32);\n}\n"
    },
    "contracts/interfaces/DssPsmAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"dss-interfaces/src/dss/AuthGemJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiJoinAbstract.sol\";\n\n\ninterface DssPsmAbstract {\n    function gemJoin() external view returns(AuthGemJoinAbstract);\n    function daiJoin() external view returns(DaiJoinAbstract);\n    function tin() external view returns(uint256);\n    function tout() external view returns(uint256);\n    function file(bytes32 what, uint256 data) external;\n    function sellGem(address usr, uint256 gemAmt) external;\n    function buyGem(address usr, uint256 gemAmt) external;\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/Liquidations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/ILiquidations.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"@yield-protocol/utils/contracts/access/Delegable.sol\";\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\";\nimport \"@yield-protocol/utils/contracts/access/Orchestrated.sol\";\n\n\n/**\n * @dev The Liquidations contract allows to liquidate undercollateralized weth vaults in a reverse Dutch auction.\n * Undercollateralized vaults can be liquidated by calling `liquidate`. This will result in debt and collateral records\n * being read and removed from the Controller using `controller.erase`.\n * Collateral from vaults can be bought with Dai using `buy`.\n * Dai taken in payment will be handed over to Treasury, and collateral assets bought will be taken from Treasury as well.\n */\ncontract Liquidations is ILiquidations, Orchestrated(), Delegable(), DecimalMath {\n\n    event Liquidation(address indexed user, uint256 started, uint256 collateral, uint256 debt);\n\n    bytes32 public constant WETH = \"ETH-A\";\n    uint256 public constant AUCTION_TIME = 3600;\n    uint256 public constant DUST = 25e15; // 0.025 ETH\n\n    ITreasury public treasury;\n    IController public override controller;\n\n    struct Vault {\n        uint128 collateral;\n        uint128 debt;\n    }\n\n    mapping(address => uint256) public liquidations;\n    mapping(address => Vault) public vaults;\n    Vault public override totals;\n\n    bool public live = true;\n\n    /// @dev The Liquidations constructor links it to the Treasury and Controller contracts.\n    constructor (\n        address controller_\n    ) public {\n        controller = IController(controller_);\n        treasury = controller.treasury();\n    }\n\n    /// @dev Only while Liquidations is not unwinding due to a MakerDAO shutdown.\n    modifier onlyLive() {\n        require(live == true, \"Controller: Not available during unwind\");\n        _;\n    }\n\n    /// @dev Overflow-protected addition, from OpenZeppelin\n    function add(uint128 a, uint128 b)\n        internal pure returns (uint128)\n    {\n        uint128 c = a + b;\n        require(c >= a, \"Liquidations: Addition overflow\");\n\n        return c;\n    }\n\n    /// @dev Overflow-protected substraction, from OpenZeppelin\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"Liquidations: Substraction overflow\");\n        uint128 c = a - b;\n\n        return c;\n    }\n\n    /// @dev Safe casting from uint256 to uint128\n    function toUint128(uint256 x) internal pure returns(uint128) {\n        require(\n            x <= type(uint128).max,\n            \"Liquidations: Cast overflow\"\n        );\n        return uint128(x);\n    }\n\n    /// @dev Disables buying at liquidations. To be called only when Treasury shuts down.\n    function shutdown() public override {\n        require(\n            treasury.live() == false,\n            \"Liquidations: Treasury is live\"\n        );\n        live = false;\n    }\n\n\n    /// @dev Return if the debt of an user is between zero and the dust level\n    /// @param user Address of the user vault\n    function aboveDustOrZero(address user) public view returns (bool) {\n        uint256 collateral = vaults[user].collateral;\n        return collateral == 0 || DUST < collateral;\n    }\n\n    /// @dev Starts a liquidation process for an undercollateralized vault.\n    /// @param user Address of the user vault to liquidate.\n    function liquidate(address user)\n        public onlyLive\n    {\n        require(\n            !controller.isCollateralized(WETH, user),\n            \"Liquidations: Vault is not undercollateralized\"\n        );\n        // A user in liquidation can be liquidated again, but doesn't restart the auction clock\n        // solium-disable-next-line security/no-block-members\n        if (liquidations[user] == 0) liquidations[user] = now;\n\n        (uint256 userCollateral, uint256 userDebt) = controller.erase(WETH, user);\n        totals = Vault({\n            collateral: add(totals.collateral, toUint128(userCollateral)),\n            debt: add(totals.debt, toUint128(userDebt))\n        });\n\n        Vault memory vault = Vault({ // TODO: Test a user that is liquidated twice\n            collateral: add(vaults[user].collateral, toUint128(userCollateral)),\n            debt: add(vaults[user].debt, toUint128(userDebt))\n        });\n        vaults[user] = vault;\n\n        emit Liquidation(user, now, userCollateral, userDebt);\n    }\n\n    /// @dev Buy a portion of a position under liquidation.\n    /// The caller pays the debt of `user`, and `from` receives an amount of collateral.\n    /// `from` can delegate to other addresses to buy for him. Also needs to use `ERC20.approve`.\n    /// @param liquidated Address of the user vault to liquidate.\n    /// @param from Address of the wallet paying Dai for liquidated collateral.\n    /// @param to Address of the wallet to send the obtained collateral to.\n    /// @param daiAmount Amount of Dai to give in exchange for liquidated collateral.\n    /// @return The amount of collateral obtained.\n    function buy(address from, address to, address liquidated, uint256 daiAmount)\n        public onlyLive\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        returns (uint256)\n    {\n        require(\n            vaults[liquidated].debt > 0,\n            \"Liquidations: Vault is not in liquidation\"\n        );\n        treasury.pushDai(from, daiAmount);\n\n        // calculate collateral to grab. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n        uint256 tokenAmount = divdrup(daiAmount, price(liquidated));\n\n        totals = Vault({\n            collateral: sub(totals.collateral, toUint128(tokenAmount)),\n            debt: sub(totals.debt, toUint128(daiAmount))\n        });\n\n        Vault memory vault = Vault({\n            collateral: sub(vaults[liquidated].collateral, toUint128(tokenAmount)),\n            debt: sub(vaults[liquidated].debt, toUint128(daiAmount))\n        });\n        vaults[liquidated] = vault;\n\n        if (vaults[liquidated].debt == 0) delete liquidations[liquidated];\n\n        treasury.pullWeth(to, tokenAmount);\n\n        require(\n            aboveDustOrZero(liquidated),\n            \"Liquidations: Below dust\"\n        );\n\n        return tokenAmount;\n    }\n\n    /// @dev Retrieve weth from a liquidations account. This weth could be a remainder from liquidations.\n    /// If any weth is not withdrawn, it will be auctioned if the user gets liquidated again.\n    /// `from` can delegate to other addresses to withdraw from him.\n    /// @param from Address of the liquidations user vault to withdraw weth from.\n    /// @param to Address of the wallet receiving the withdrawn weth.\n    /// @param tokenAmount Amount of Weth to withdraw.\n    function withdraw(address from, address to, uint256 tokenAmount)\n        public onlyLive\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n    {\n        Vault storage vault = vaults[from];\n        require(\n            vault.debt == 0,\n            \"Liquidations: User still in liquidation\"\n        );\n\n        totals.collateral = sub(totals.collateral, toUint128(tokenAmount));\n        vault.collateral = sub(vault.collateral, toUint128(tokenAmount));\n\n        treasury.pullWeth(to, tokenAmount);\n    }\n\n    /// @dev Removes all collateral and debt for an user.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param user Address of the user vault\n    /// @return The amounts of collateral and debt removed from Liquidations.\n    function erase(address user)\n        public override\n        onlyOrchestrated(\"Liquidations: Not Authorized\")\n        returns (uint128, uint128)\n    {\n        Vault storage vault = vaults[user];\n        uint128 collateral = vault.collateral;\n        uint128 debt = vault.debt;\n\n        totals = Vault({\n            collateral: sub(totals.collateral, collateral),\n            debt: sub(totals.debt, debt)\n        });\n        delete vaults[user];\n\n        return (collateral, debt);\n    }\n\n    /// @dev Return price of a collateral unit, in dai, at the present moment, for a given user\n    /// @param user Address of the user vault in liquidation.\n    // dai = price * collateral\n    //\n    //                collateral      1      min(auction, elapsed)\n    // price = 1 / (------------- * (--- + -----------------------))\n    //                   debt         2       2 * auction\n    function price(address user) public view returns (uint256) {\n        require(\n            liquidations[user] > 0,\n            \"Liquidations: Vault is not targeted\"\n        );\n        uint256 dividend1 = uint256(vaults[user].collateral);\n        uint256 divisor1 = uint256(vaults[user].debt);\n        uint256 term1 = dividend1.mul(UNIT).div(divisor1);\n        uint256 dividend3 = Math.min(AUCTION_TIME, now - liquidations[user]); // - unlikely to overflow\n        uint256 divisor3 = AUCTION_TIME.mul(2);\n        uint256 term2 = UNIT.div(2);\n        uint256 term3 = dividend3.mul(UNIT).div(divisor3);\n        return divd(UNIT, muld(term1, term2 + term3)); // + unlikely to overflow\n    }\n}\n"
    },
    "@yield-protocol/utils/contracts/access/Delegable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"../interfaces/IDelegable.sol\";\n\n\n/// @dev Delegable enables users to delegate their account management to other users.\n/// Delegable implements addDelegateBySignature, to add delegates using a signature instead of a separate transaction.\ncontract Delegable is IDelegable {\n    event Delegate(address indexed user, address indexed delegate, bool enabled);\n\n    // keccak256(\"Signature(address user,address delegate,uint256 nonce,uint256 deadline)\");\n    bytes32 public immutable SIGNATURE_TYPEHASH = 0x0d077601844dd17f704bafff948229d27f33b57445915754dfe3d095fda2beb7;\n    bytes32 public immutable DELEGABLE_DOMAIN;\n    mapping(address => uint) public signatureCount;\n\n    mapping(address => mapping(address => bool)) public override delegated;\n\n    constructor () public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        DELEGABLE_DOMAIN = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes('Yield')),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Require that msg.sender is the account holder or a delegate\n    modifier onlyHolderOrDelegate(address holder, string memory errorMessage) {\n        require(\n            msg.sender == holder || delegated[holder][msg.sender],\n            errorMessage\n        );\n        _;\n    }\n\n    /// @dev Enable a delegate to act on the behalf of caller\n    function addDelegate(address delegate) public override {\n        _addDelegate(msg.sender, delegate);\n    }\n\n    /// @dev Stop a delegate from acting on the behalf of caller\n    function revokeDelegate(address delegate) public {\n        _revokeDelegate(msg.sender, delegate);\n    }\n\n    /// @dev Add a delegate through an encoded signature\n    function addDelegateBySignature(address user, address delegate, uint deadline, uint8 v, bytes32 r, bytes32 s) public override {\n        require(deadline >= block.timestamp, 'Delegable: Signature expired');\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                SIGNATURE_TYPEHASH,\n                user,\n                delegate,\n                signatureCount[user]++,\n                deadline\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DELEGABLE_DOMAIN,\n                hashStruct\n            )\n        );\n        address signer = ecrecover(digest, v, r, s);\n        require(\n            signer != address(0) && signer == user,\n            'Delegable: Invalid signature'\n        );\n\n        _addDelegate(user, delegate);\n    }\n\n    /// @dev Enable a delegate to act on the behalf of an user\n    function _addDelegate(address user, address delegate) internal {\n        require(!delegated[user][delegate], \"Delegable: Already delegated\");\n        delegated[user][delegate] = true;\n        emit Delegate(user, delegate, true);\n    }\n\n    /// @dev Stop a delegate from acting on the behalf of an user\n    function _revokeDelegate(address user, address delegate) internal {\n        require(delegated[user][delegate], \"Delegable: Already undelegated\");\n        delegated[user][delegate] = false;\n        emit Delegate(user, delegate, false);\n    }\n}\n"
    },
    "@yield-protocol/utils/contracts/access/Orchestrated.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\n/**\n * @dev Orchestrated allows to define static access control between multiple contracts.\n * This contract would be used as a parent contract of any contract that needs to restrict access to some methods,\n * which would be marked with the `onlyOrchestrated` modifier.\n * During deployment, the contract deployer (`owner`) can register any contracts that have privileged access by calling `orchestrate`.\n * Once deployment is completed, `owner` should call `transferOwnership(address(0))` to avoid any more contracts ever gaining privileged access.\n */\n\ncontract Orchestrated is Ownable {\n    event GrantedAccess(address access, bytes4 signature);\n\n    mapping(address => mapping (bytes4 => bool)) public orchestration;\n\n    constructor () public Ownable() {}\n\n    /// @dev Restrict usage to authorized users\n    /// @param err The error to display if the validation fails \n    modifier onlyOrchestrated(string memory err) {\n        require(orchestration[msg.sender][msg.sig], err);\n        _;\n    }\n\n    /// @dev Add orchestration\n    /// @param user Address of user or contract having access to this contract.\n    /// @param signature bytes4 signature of the function we are giving orchestrated access to.\n    /// It seems to me a bad idea to give access to humans, and would use this only for predictable smart contracts.\n    function orchestrate(address user, bytes4 signature) public onlyOwner {\n        orchestration[user][signature] = true;\n        emit GrantedAccess(user, signature);\n    }\n\n    /// @dev Adds orchestration for the provided function signatures\n    function batchOrchestrate(address user, bytes4[] memory signatures) public onlyOwner {\n        for (uint256 i = 0; i < signatures.length; i++) {\n            orchestrate(user, signatures[i]);\n        }\n    }\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@yield-protocol/utils/contracts/access/Delegable.sol\";\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\";\nimport \"@yield-protocol/utils/contracts/access/Orchestrated.sol\";\nimport \"dss-interfaces/src/dss/VatAbstract.sol\";\nimport \"dss-interfaces/src/dss/PotAbstract.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IController.sol\";\nimport \"./interfaces/IFYDai.sol\";\n\n\n/**\n * @dev The Controller manages collateral and debt levels for all users, and it is a major user entry point for the Yield protocol.\n * Controller keeps track of a number of fyDai contracts.\n * Controller allows users to post and withdraw Chai and Weth collateral.\n * Any transactions resulting in a user weth collateral below dust are reverted.\n * Controller allows users to borrow fyDai against their Chai and Weth collateral.\n * Controller allows users to repay their fyDai debt with fyDai or with Dai.\n * Controller integrates with fyDai contracts for minting fyDai on borrowing, and burning fyDai on repaying debt with fyDai.\n * Controller relies on Treasury for all other asset transfers.\n * Controller allows orchestrated contracts to erase any amount of debt or collateral for an user. This is to be used during liquidations or during unwind.\n * Users can delegate the control of their accounts in Controllers to any address.\n */\ncontract Controller is IController, Orchestrated(), Delegable(), DecimalMath {\n    using SafeMath for uint256;\n\n    event Posted(bytes32 indexed collateral, address indexed user, int256 amount);\n    event Borrowed(bytes32 indexed collateral, uint256 indexed maturity, address indexed user, int256 amount);\n\n    bytes32 public constant CHAI = \"CHAI\";\n    bytes32 public constant WETH = \"ETH-A\";\n    uint256 public constant DUST = 50e15; // 0.05 ETH\n\n    VatAbstract public vat;\n    PotAbstract public pot;\n    ITreasury public override treasury;\n\n    mapping(uint256 => IFYDai) public override series;                 // FYDai series, indexed by maturity\n    uint256[] public override seriesIterator;                         // We need to know all the series\n\n    mapping(bytes32 => mapping(address => uint256)) public override posted;                        // Collateral posted by each user\n    mapping(bytes32 => mapping(uint256 => mapping(address => uint256))) public override debtFYDai;  // Debt owed by each user, by series\n\n    bool public live = true;\n\n    /// @dev Set up addresses for vat, pot and Treasury.\n    constructor (\n        address treasury_,\n        address[] memory fyDais\n\n    ) public {\n        treasury = ITreasury(treasury_);\n        vat = treasury.vat();\n        pot = treasury.pot();\n        for (uint256 i = 0; i < fyDais.length; i += 1) {\n            addSeries(fyDais[i]);\n        }\n    }\n\n    /// @dev Modified functions only callable while the Controller is not unwinding due to a MakerDAO shutdown.\n    modifier onlyLive() {\n        require(live == true, \"Controller: Not available during unwind\");\n        _;\n    }\n\n    /// @dev Only valid collateral types are Weth and Chai.\n    modifier validCollateral(bytes32 collateral) {\n        require(\n            collateral == WETH || collateral == CHAI,\n            \"Controller: Unrecognized collateral\"\n        );\n        _;\n    }\n\n    /// @dev Only series added through `addSeries` are valid.\n    modifier validSeries(uint256 maturity) {\n        require(\n            containsSeries(maturity),\n            \"Controller: Unrecognized series\"\n        );\n        _;\n    }\n\n    /// @dev Safe casting from uint256 to int256\n    function toInt256(uint256 x) internal pure returns(int256) {\n        require(\n            x <= uint256(type(int256).max),\n            \"Controller: Cast overflow\"\n        );\n        return int256(x);\n    }\n\n    /// @dev Disables post, withdraw, borrow and repay. To be called only when Treasury shuts down.\n    function shutdown() public override {\n        require(\n            treasury.live() == false,\n            \"Controller: Treasury is live\"\n        );\n        live = false;\n    }\n\n    /// @dev Return if the borrowing power for a given collateral of a user is equal or greater\n    /// than its debt for the same collateral\n    /// @param collateral Valid collateral type\n    /// @param user Address of the user vault\n    function isCollateralized(bytes32 collateral, address user) public view override returns (bool) {\n        return powerOf(collateral, user) >= totalDebtDai(collateral, user);\n    }\n\n    /// @dev Return if the collateral of an user is between zero and the dust level\n    /// @param collateral Valid collateral type\n    /// @param user Address of the user vault\n    function aboveDustOrZero(bytes32 collateral, address user) public view returns (bool) {\n        uint256 postedCollateral = posted[collateral][user];\n        return postedCollateral == 0 || DUST < postedCollateral;\n    }\n\n    /// @dev Return the total number of series registered\n    function totalSeries() public view override returns (uint256) {\n        return seriesIterator.length;\n    }\n\n    /// @dev Returns if a series has been added to the Controller.\n    /// @param maturity Maturity of the series to verify.\n    function containsSeries(uint256 maturity) public view override returns (bool) {\n        return address(series[maturity]) != address(0);\n    }\n\n    /// @dev Adds an fyDai series to this Controller\n    /// After deployment, ownership should be renounced, so that no more series can be added.\n    /// @param fyDaiContract Address of the fyDai series to add.\n    function addSeries(address fyDaiContract) private {\n        uint256 maturity = IFYDai(fyDaiContract).maturity();\n        require(\n            !containsSeries(maturity),\n            \"Controller: Series already added\"\n        );\n        series[maturity] = IFYDai(fyDaiContract);\n        seriesIterator.push(maturity);\n    }\n\n    /// @dev Dai equivalent of an fyDai amount.\n    /// After maturity, the Dai value of an fyDai grows according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\n    /// @param collateral Valid collateral type\n    /// @param maturity Maturity of an added series\n    /// @param fyDaiAmount Amount of fyDai to convert.\n    /// @return Dai equivalent of an fyDai amount.\n    function inDai(bytes32 collateral, uint256 maturity, uint256 fyDaiAmount)\n        public view override\n        validCollateral(collateral)\n        returns (uint256)\n    {\n        IFYDai fyDai = series[maturity];\n        if (fyDai.isMature()){\n            if (collateral == WETH){\n                return muld(fyDaiAmount, fyDai.rateGrowth());\n            } else if (collateral == CHAI) {\n                return muld(fyDaiAmount, fyDai.chiGrowth());\n            }\n        } else {\n            return fyDaiAmount;\n        }\n    }\n\n    /// @dev fyDai equivalent of a Dai amount.\n    /// After maturity, the fyDai value of a Dai decreases according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\n    /// @param collateral Valid collateral type\n    /// @param maturity Maturity of an added series\n    /// @param daiAmount Amount of Dai to convert.\n    /// @return fyDai equivalent of a Dai amount.\n    function inFYDai(bytes32 collateral, uint256 maturity, uint256 daiAmount)\n        public view override\n        validCollateral(collateral)\n        returns (uint256)\n    {\n        IFYDai fyDai = series[maturity];\n        if (fyDai.isMature()){\n            if (collateral == WETH){\n                return divd(daiAmount, fyDai.rateGrowth());\n            } else if (collateral == CHAI) {\n                return divd(daiAmount, fyDai.chiGrowth());\n            }\n        } else {\n            return daiAmount;\n        }\n    }\n\n    /// @dev Debt in dai of an user\n    /// After maturity, the Dai debt of a position grows according to either the stability fee (for WETH collateral) or the Dai Saving Rate (for Chai collateral).\n    /// @param collateral Valid collateral type\n    /// @param maturity Maturity of an added series\n    /// @param user Address of the user vault\n    /// @return Debt in dai of an user\n    //\n    //                        rate_now\n    // debt_now = debt_mat * ----------\n    //                        rate_mat\n    //\n    function debtDai(bytes32 collateral, uint256 maturity, address user) public view override returns (uint256) {\n        return inDai(collateral, maturity, debtFYDai[collateral][maturity][user]);\n    }\n\n    /// @dev Total debt of an user across all series, in Dai\n    /// The debt is summed across all series, taking into account interest on the debt after a series matures.\n    /// This function loops through all maturities, limiting the contract to hundreds of maturities.\n    /// @param collateral Valid collateral type\n    /// @param user Address of the user vault\n    /// @return Total debt of an user across all series, in Dai\n    function totalDebtDai(bytes32 collateral, address user) public view override returns (uint256) {\n        uint256 totalDebt;\n        uint256[] memory _seriesIterator = seriesIterator;\n        for (uint256 i = 0; i < _seriesIterator.length; i += 1) {\n            if (debtFYDai[collateral][_seriesIterator[i]][user] > 0) {\n                totalDebt = totalDebt.add(debtDai(collateral, _seriesIterator[i], user));\n            }\n        } // We don't expect hundreds of maturities per controller\n        return totalDebt;\n    }\n\n    /// @dev Borrowing power (in dai) of a user for a specific series and collateral.\n    /// @param collateral Valid collateral type\n    /// @param user Address of the user vault\n    /// @return Borrowing power of an user in dai.\n    //\n    // powerOf[user](wad) = posted[user](wad) * price()(ray)\n    //\n    function powerOf(bytes32 collateral, address user) public view returns (uint256) {\n        // dai = price * collateral\n        if (collateral == WETH){\n            (,, uint256 spot,,) = vat.ilks(WETH);  // Stability fee and collateralization ratio for Weth\n            return muld(posted[collateral][user], spot);\n        } else if (collateral == CHAI) {\n            uint256 chi = pot.chi();\n            return muld(posted[collateral][user], chi);\n        } else {\n            revert(\"Controller: Invalid collateral type\");\n        }\n    }\n\n    /// @dev Returns the amount of collateral locked in borrowing operations.\n    /// @param collateral Valid collateral type.\n    /// @param user Address of the user vault.\n    function locked(bytes32 collateral, address user)\n        public view override\n        validCollateral(collateral)\n        returns (uint256)\n    {\n        if (collateral == WETH){\n            (,, uint256 spot,,) = vat.ilks(WETH);  // Stability fee and collateralization ratio for Weth\n            return divdrup(totalDebtDai(collateral, user), spot);\n        } else if (collateral == CHAI) {\n            return divdrup(totalDebtDai(collateral, user), pot.chi());\n        }\n    }\n\n    /// @dev Takes collateral assets from `from` address, and credits them to `to` collateral account.\n    /// `from` can delegate to other addresses to take assets from him. Also needs to use `ERC20.approve`.\n    /// Calling ERC20.approve for Treasury contract is a prerequisite to this function\n    /// @param collateral Valid collateral type.\n    /// @param from Wallet to take collateral from.\n    /// @param to Yield vault to put the collateral in.\n    /// @param amount Amount of collateral to move.\n    // from --- Token ---> us(to)\n    function post(bytes32 collateral, address from, address to, uint256 amount)\n        public override \n        validCollateral(collateral)\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        onlyLive\n    {\n        posted[collateral][to] = posted[collateral][to].add(amount);\n\n        if (collateral == WETH){\n            require(\n                aboveDustOrZero(collateral, to),\n                \"Controller: Below dust\"\n            );\n            treasury.pushWeth(from, amount);\n        } else if (collateral == CHAI) {\n            treasury.pushChai(from, amount);\n        }\n        \n        emit Posted(collateral, to, toInt256(amount));\n    }\n\n    /// @dev Returns collateral to `to` wallet, taking it from `from` Yield vault account.\n    /// `from` can delegate to other addresses to take assets from him.\n    /// @param collateral Valid collateral type.\n    /// @param from Yield vault to take collateral from.\n    /// @param to Wallet to put the collateral in.\n    /// @param amount Amount of collateral to move.\n    // us(from) --- Token ---> to\n    function withdraw(bytes32 collateral, address from, address to, uint256 amount)\n        public override\n        validCollateral(collateral)\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        onlyLive\n    {\n        posted[collateral][from] = posted[collateral][from].sub(amount); // Will revert if not enough posted\n\n        require(\n            isCollateralized(collateral, from),\n            \"Controller: Too much debt\"\n        );\n\n        if (collateral == WETH){\n            require(\n                aboveDustOrZero(collateral, from),\n                \"Controller: Below dust\"\n            );\n            treasury.pullWeth(to, amount);\n        } else if (collateral == CHAI) {\n            treasury.pullChai(to, amount);\n        }\n\n        emit Posted(collateral, from, -toInt256(amount));\n    }\n\n    /// @dev Mint fyDai for a given series for wallet `to` by increasing the user debt in Yield vault `from`\n    /// `from` can delegate to other addresses to borrow using his vault.\n    /// The collateral needed changes according to series maturity and MakerDAO rate and chi, depending on collateral type.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param from Yield vault that gets an increased debt.\n    /// @param to Wallet to put the fyDai in.\n    /// @param fyDaiAmount Amount of fyDai to borrow.\n    //\n    // posted[user](wad) >= (debtFYDai[user](wad)) * amount (wad)) * collateralization (ray)\n    //\n    // us(from) --- fyDai ---> to\n    // debt++\n    function borrow(bytes32 collateral, uint256 maturity, address from, address to, uint256 fyDaiAmount)\n        public override\n        validCollateral(collateral)\n        validSeries(maturity)\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        onlyLive\n    {\n        IFYDai fyDai = series[maturity];\n\n        debtFYDai[collateral][maturity][from] = debtFYDai[collateral][maturity][from].add(fyDaiAmount);\n\n        require(\n            isCollateralized(collateral, from),\n            \"Controller: Too much debt\"\n        );\n\n        fyDai.mint(to, fyDaiAmount);\n        emit Borrowed(collateral, maturity, from, toInt256(fyDaiAmount));\n    }\n\n    /// @dev Burns fyDai from `from` wallet to repay debt in a Yield Vault.\n    /// User debt is decreased for the given collateral and fyDai series, in Yield vault `to`.\n    /// `from` can delegate to other addresses to take fyDai from him for the repayment.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param from Wallet providing the fyDai for repayment.\n    /// @param to Yield vault to repay debt for.\n    /// @param fyDaiAmount Amount of fyDai to use for debt repayment.\n    //\n    //                                                  debt_nominal\n    // debt_discounted = debt_nominal - repay_amount * ---------------\n    //                                                  debt_now\n    //\n    // user(from) --- fyDai ---> us(to)\n    // debt--\n    function repayFYDai(bytes32 collateral, uint256 maturity, address from, address to, uint256 fyDaiAmount)\n        public override\n        validCollateral(collateral)\n        validSeries(maturity)\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        onlyLive\n        returns (uint256)\n    {\n        uint256 toRepay = Math.min(fyDaiAmount, debtFYDai[collateral][maturity][to]);\n        series[maturity].burn(from, toRepay);\n        _repay(collateral, maturity, to, toRepay);\n        return toRepay;\n    }\n\n    /// @dev Burns Dai from `from` wallet to repay debt in a Yield Vault.\n    /// User debt is decreased for the given collateral and fyDai series, in Yield vault `to`.\n    /// The amount of debt repaid changes according to series maturity and MakerDAO rate and chi, depending on collateral type.\n    /// `from` can delegate to other addresses to take Dai from him for the repayment.\n    /// Calling ERC20.approve for Treasury contract is a prerequisite to this function\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param from Wallet providing the Dai for repayment.\n    /// @param to Yield vault to repay debt for.\n    /// @param daiAmount Amount of Dai to use for debt repayment.\n    //\n    //                                                  debt_nominal\n    // debt_discounted = debt_nominal - repay_amount * ---------------\n    //                                                  debt_now\n    //\n    // user --- dai ---> us\n    // debt--\n    function repayDai(bytes32 collateral, uint256 maturity, address from, address to, uint256 daiAmount)\n        public override\n        validCollateral(collateral)\n        validSeries(maturity)\n        onlyHolderOrDelegate(from, \"Controller: Only Holder Or Delegate\")\n        onlyLive\n        returns (uint256)\n    {\n        uint256 toRepay = Math.min(daiAmount, debtDai(collateral, maturity, to));\n        treasury.pushDai(from, toRepay);                                      // Have Treasury process the dai\n        _repay(collateral, maturity, to, inFYDai(collateral, maturity, toRepay));\n        return toRepay;\n    }\n\n    /// @dev Removes an amount of debt from an user's vault.\n    /// Internal function.\n    /// @param collateral Valid collateral type.\n    /// @param maturity Maturity of an added series\n    /// @param user Yield vault to repay debt for.\n    /// @param fyDaiAmount Amount of fyDai to use for debt repayment.\n\n    //\n    //                                                principal\n    // principal_repayment = gross_repayment * ----------------------\n    //                                          principal + interest\n    //    \n    function _repay(bytes32 collateral, uint256 maturity, address user, uint256 fyDaiAmount) internal {\n        debtFYDai[collateral][maturity][user] = debtFYDai[collateral][maturity][user].sub(fyDaiAmount);\n\n        emit Borrowed(collateral, maturity, user, -toInt256(fyDaiAmount));\n    }\n\n    /// @dev Removes all collateral and debt for an user, for a given collateral type.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param collateral Valid collateral type.\n    /// @param user Address of the user vault\n    /// @return The amounts of collateral and debt removed from Controller.\n    function erase(bytes32 collateral, address user)\n        public override\n        validCollateral(collateral)\n        onlyOrchestrated(\"Controller: Not Authorized\")\n        returns (uint256, uint256)\n    {\n        uint256 userCollateral = posted[collateral][user];\n        delete posted[collateral][user];\n\n        uint256 userDebt;\n        uint256[] memory _seriesIterator = seriesIterator;\n        for (uint256 i = 0; i < _seriesIterator.length; i += 1) {\n            uint256 maturity = _seriesIterator[i];\n            userDebt = userDebt.add(debtDai(collateral, maturity, user)); // SafeMath shouldn't be needed\n            delete debtFYDai[collateral][maturity][user];\n        } // We don't expect hundreds of maturities per controller\n\n        return (userCollateral, userDebt);\n    }\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/FYDai.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"dss-interfaces/src/dss/VatAbstract.sol\";\nimport \"dss-interfaces/src/dss/PotAbstract.sol\";\nimport \"./interfaces/ITreasury.sol\";\nimport \"./interfaces/IFYDai.sol\";\nimport \"./interfaces/IFlashMinter.sol\";\nimport \"@yield-protocol/utils/contracts/access/Delegable.sol\";\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\";\nimport \"@yield-protocol/utils/contracts/access/Orchestrated.sol\";\nimport \"@yield-protocol/utils/contracts/token/ERC20Permit.sol\";\n\n\n/**\n * @dev fyDai is an fyToken targeting Chai.\n * Each fyDai contract has a specific maturity time. One fyDai is worth one Chai at or after maturity time.\n * At maturity, the fyDai can be triggered to mature, which records the current rate and chi from MakerDAO and enables redemption.\n * Redeeming an fyDai means burning it, and the contract will retrieve Dai from Treasury equal to one Dai times the growth in chi since maturity.\n * fyDai also tracks the MakerDAO stability fee accumulator at the time of maturity, and the growth since. This is not used internally.\n * Minting and burning of fyDai is restricted to orchestrated contracts. Redeeming and flash-minting is allowed to anyone.\n */\n\ncontract FYDai is IFYDai, Orchestrated(), Delegable(), DecimalMath, ERC20Permit  {\n\n    event Redeemed(address indexed from, address indexed to, uint256 fyDaiIn, uint256 daiOut);\n    event Matured(uint256 rate, uint256 chi);\n\n    bytes32 public constant WETH = \"ETH-A\";\n\n    uint256 constant internal MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n\n    VatAbstract public vat;\n    PotAbstract public pot;\n    ITreasury public treasury;\n\n    bool public override isMature;\n    uint256 public override maturity;\n    uint256 public override chi0;      // Chi at maturity\n    uint256 public override rate0;     // Rate at maturity\n\n    uint public override unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'FYDai: Locked');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n    \n    /// @dev The constructor:\n    /// Sets the name and symbol for the fyDai token.\n    /// Connects to Vat, Jug, Pot and Treasury.\n    /// Sets the maturity date for the fyDai, in unix time.\n    /// Initializes chi and rate at maturity time as 1.0 with 27 decimals.\n    constructor(\n        address treasury_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    ) public ERC20Permit(name, symbol) {\n        // solium-disable-next-line security/no-block-members\n        require(maturity_ > now && maturity_ < now + MAX_TIME_TO_MATURITY, \"FYDai: Invalid maturity\");\n        treasury = ITreasury(treasury_);\n        vat = treasury.vat();\n        pot = treasury.pot();\n        maturity = maturity_;\n        chi0 = UNIT;\n        rate0 = UNIT;\n    }\n\n    /// @dev Chi differential between maturity and now in RAY. Returns 1.0 if not mature.\n    /// If rateGrowth < chiGrowth, returns rate.\n    //\n    //          chi_now\n    // chi() = ---------\n    //          chi_mat\n    //\n    function chiGrowth() public view override returns(uint256){\n        if (isMature != true) return chi0;\n        return Math.min(rateGrowth(), divd(pot.chi(), chi0)); // Rounding in favour of the protocol\n    }\n\n    /// @dev Rate differential between maturity and now in RAY. Returns 1.0 if not mature.\n    /// rateGrowth is floored to 1.0.\n    //\n    //                 rate_now\n    // rateGrowth() = ----------\n    //                 rate_mat\n    //\n    function rateGrowth() public view override returns(uint256){\n        if (isMature != true) return rate0;\n        (, uint256 rate,,,) = vat.ilks(WETH);\n        return Math.max(UNIT, divdrup(rate, rate0)); // Rounding in favour of the protocol\n    }\n\n    /// @dev Mature fyDai and capture chi and rate\n    function mature() public override {\n        require(\n            // solium-disable-next-line security/no-block-members\n            now > maturity,\n            \"FYDai: Too early to mature\"\n        );\n        require(\n            isMature != true,\n            \"FYDai: Already matured\"\n        );\n        (, rate0,,,) = vat.ilks(WETH); // Retrieve the MakerDAO Vat\n        rate0 = Math.max(rate0, UNIT); // Floor it at 1.0\n        chi0 = pot.chi();\n        isMature = true;\n        emit Matured(rate0, chi0);\n    }\n\n    /// @dev Burn fyDai and return their dai equivalent value, pulled from the Treasury\n    /// During unwind, `treasury.pullDai()` will revert which is right.\n    /// `from` needs to tell fyDai to approve the burning of the fyDai tokens.\n    /// `from` can delegate to other addresses to redeem his fyDai and put the Dai proceeds in the `to` wallet.\n    /// The collateral needed changes according to series maturity and MakerDAO rate and chi, depending on collateral type.\n    /// @param from Wallet to burn fyDai from.\n    /// @param to Wallet to put the Dai in.\n    /// @param fyDaiAmount Amount of fyDai to burn.\n    // from --- fyDai ---> us\n    // us   --- Dai  ---> to\n    function redeem(address from, address to, uint256 fyDaiAmount)\n        public onlyHolderOrDelegate(from, \"FYDai: Only Holder Or Delegate\") lock override \n        returns (uint256)\n    {\n        require(\n            isMature == true,\n            \"FYDai: fyDai is not mature\"\n        );\n        _burn(from, fyDaiAmount);                              // Burn fyDai from `from`\n        uint256 daiAmount = muld(fyDaiAmount, chiGrowth());    // User gets interest for holding after maturity\n        treasury.pullDai(to, daiAmount);                     // Give dai to `to`, from Treasury\n        emit Redeemed(from, to, fyDaiAmount, daiAmount);\n        return daiAmount;\n    }\n\n    /// @dev Flash-mint fyDai. Calls back on `IFlashMinter.executeOnFlashMint()`\n    /// @param fyDaiAmount Amount of fyDai to mint.\n    /// @param data User-defined data to pass on to `executeOnFlashMint()`\n    function flashMint(uint256 fyDaiAmount, bytes calldata data) external lock override {\n        _mint(msg.sender, fyDaiAmount);\n        IFlashMinter(msg.sender).executeOnFlashMint(fyDaiAmount, data);\n        _burn(msg.sender, fyDaiAmount);\n    }\n\n    /// @dev Mint fyDai. Only callable by Controller contracts.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to mint the fyDai in.\n    /// @param fyDaiAmount Amount of fyDai to mint.\n    function mint(address to, uint256 fyDaiAmount) public override onlyOrchestrated(\"FYDai: Not Authorized\") {\n        _mint(to, fyDaiAmount);\n    }\n\n    /// @dev Burn fyDai. Only callable by Controller contracts.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to burn the fyDai from.\n    /// @param fyDaiAmount Amount of fyDai to burn.\n    function burn(address from, uint256 fyDaiAmount) public override onlyOrchestrated(\"FYDai: Not Authorized\") {\n        _burn(from, fyDaiAmount);\n    }\n\n    /// @dev Creates `fyDaiAmount` tokens and assigns them to `to`, increasing the total supply, up to a limit of 2**112.\n    /// @param to Wallet to mint the fyDai in.\n    /// @param fyDaiAmount Amount of fyDai to mint.\n    function _mint(address to, uint256 fyDaiAmount) internal override {\n        super._mint(to, fyDaiAmount);\n        require(totalSupply() <= 5192296858534827628530496329220096, \"FYDai: Total supply limit exceeded\"); // 2**112\n    }\n}\n"
    },
    "@yield-protocol/vault-v1/contracts/interfaces/IFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\n\ninterface IFlashMinter {\n    function executeOnFlashMint(uint256 fyDaiAmount, bytes calldata data) external;\n}\n"
    },
    "@yield-protocol/utils/contracts/token/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/IERC2612.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to use their tokens\n * without sending any transactions by setting {IERC20-allowance} with a\n * signature using the {permit} method, and then spend them via\n * {IERC20-transferFrom}.\n *\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\n */\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public immutable DOMAIN_SEPARATOR;\n\n    constructor(string memory name_, string memory symbol_) internal ERC20(name_, symbol_) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name_)),\n                keccak256(bytes(version())),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns(string memory) { return \"1\"; }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _approve(owner, spender, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mocks/USDCMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@yield-protocol/utils/contracts/token/ERC20Permit.sol\";\n\n\ncontract USDCMock is ERC20Permit {\n    // Values taken from https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#readProxyContract\n    // bytes32 constant override public DOMAIN_SEPARATOR = 0x06c37168a7db5138defc7866392bb87a741f9b3d104deb5094588ce041cae335;\n    // bytes32 constant override public PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    constructor () public ERC20Permit(\"USD Coin\", \"USDC\") {\n        _setupDecimals(6);\n    }\n\n    function version() public pure override returns(string memory) { return \"2\"; }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public {\n        _burn(from, amount);\n    }\n}\n"
    },
    "@yield-protocol/yieldspace-v1/contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@yield-protocol/utils/contracts/access/Delegable.sol\";\nimport \"@yield-protocol/utils/contracts/token/ERC20Permit.sol\";\nimport \"@yield-protocol/vault-v1/contracts/interfaces/IFYDai.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./YieldMath.sol\";\n\n\n/// @dev The Pool contract exchanges Dai for fyDai at a price defined by a specific formula.\ncontract Pool is IPool, Delegable(), ERC20Permit {\n\n    event Trade(uint256 maturity, address indexed from, address indexed to, int256 daiTokens, int256 fyDaiTokens);\n    event Liquidity(uint256 maturity, address indexed from, address indexed to, int256 daiTokens, int256 fyDaiTokens, int256 poolTokens);\n\n    int128 constant public k = int128(uint256((1 << 64)) / 126144000); // 1 / Seconds in 4 years, in 64.64\n    int128 constant public g1 = int128(uint256((950 << 64)) / 1000); // To be used when selling Dai to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n    int128 constant public g2 = int128(uint256((1000 << 64)) / 950); // To be used when selling fyDai to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n    uint128 immutable public maturity;\n\n    IERC20 public override dai;\n    IFYDai public override fyDai;\n\n    constructor(address dai_, address fyDai_, string memory name_, string memory symbol_)\n        public\n        ERC20Permit(name_, symbol_)\n    {\n        dai = IERC20(dai_);\n        fyDai = IFYDai(fyDai_);\n\n        maturity = toUint128(fyDai.maturity());\n    }\n\n    /// @dev Trading can only be done before maturity\n    modifier beforeMaturity() {\n        require(\n            now < maturity,\n            \"Pool: Too late\"\n        );\n        _;\n    }\n\n    /// @dev Overflow-protected addition, from OpenZeppelin\n    function add(uint128 a, uint128 b)\n        internal pure returns (uint128)\n    {\n        uint128 c = a + b;\n        require(c >= a, \"Pool: Dai reserves too high\");\n\n        return c;\n    }\n\n    /// @dev Overflow-protected substraction, from OpenZeppelin\n    function sub(uint128 a, uint128 b) internal pure returns (uint128) {\n        require(b <= a, \"Pool: fyDai reserves too low\");\n        uint128 c = a - b;\n\n        return c;\n    }\n\n    /// @dev Safe casting from uint256 to uint128\n    function toUint128(uint256 x) internal pure returns(uint128) {\n        require(\n            x <= type(uint128).max,\n            \"Pool: Cast overflow\"\n        );\n        return uint128(x);\n    }\n\n    /// @dev Safe casting from uint256 to int256\n    function toInt256(uint256 x) internal pure returns(int256) {\n        require(\n            x <= uint256(type(int256).max),\n            \"Pool: Cast overflow\"\n        );\n        return int256(x);\n    }\n\n    /// @dev Mint initial liquidity tokens.\n    /// The liquidity provider needs to have called `dai.approve`\n    /// @param daiIn The initial Dai liquidity to provide.\n    function init(uint256 daiIn)\n        internal\n        beforeMaturity\n        returns (uint256)\n    {\n        require(\n            totalSupply() == 0,\n            \"Pool: Already initialized\"\n        );\n        // no fyDai transferred, because initial fyDai deposit is entirely virtual\n        dai.transferFrom(msg.sender, address(this), daiIn);\n        _mint(msg.sender, daiIn);\n        emit Liquidity(maturity, msg.sender, msg.sender, -toInt256(daiIn), 0, toInt256(daiIn));\n\n        return daiIn;\n    }\n\n    /// @dev Mint liquidity tokens in exchange for adding dai and fyDai\n    /// The liquidity provider needs to have called `dai.approve` and `fyDai.approve`.\n    /// @param from Wallet providing the dai and fyDai. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param daiOffered Amount of `dai` being invested, an appropriate amount of `fyDai` to be invested alongside will be calculated and taken by this function from the caller.\n    /// @return The amount of liquidity tokens minted.\n    function mint(address from, address to, uint256 daiOffered)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns (uint256)\n    {\n        uint256 supply = totalSupply();\n        if (supply == 0) return init(daiOffered);\n\n        uint256 daiReserves = dai.balanceOf(address(this));\n        // use the actual reserves rather than the virtual reserves\n        uint256 fyDaiReserves = fyDai.balanceOf(address(this));\n        uint256 tokensMinted = supply.mul(daiOffered).div(daiReserves);\n        uint256 fyDaiRequired = fyDaiReserves.mul(tokensMinted).div(supply);\n\n        require(daiReserves.add(daiOffered) <= type(uint128).max); // daiReserves can't go over type(uint128).max\n        require(supply.add(fyDaiReserves.add(fyDaiRequired)) <= type(uint128).max); // fyDaiReserves can't go over type(uint128).max\n\n        require(dai.transferFrom(from, address(this), daiOffered));\n        require(fyDai.transferFrom(from, address(this), fyDaiRequired));\n        _mint(to, tokensMinted);\n        emit Liquidity(maturity, from, to, -toInt256(daiOffered), -toInt256(fyDaiRequired), toInt256(tokensMinted));\n\n        return tokensMinted;\n    }\n\n    /// @dev Burn liquidity tokens in exchange for dai and fyDai.\n    /// The liquidity provider needs to have called `pool.approve`.\n    /// @param from Wallet providing the liquidity tokens. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the dai and fyDai.\n    /// @param tokensBurned Amount of liquidity tokens being burned.\n    /// @return The amount of reserve tokens returned (daiTokens, fyDaiTokens).\n    function burn(address from, address to, uint256 tokensBurned)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns (uint256, uint256)\n    {\n        uint256 supply = totalSupply();\n        uint256 daiReserves = dai.balanceOf(address(this));\n        // use the actual reserves rather than the virtual reserves\n        uint256 daiReturned;\n        uint256 fyDaiReturned;\n        { // avoiding stack too deep\n            uint256 fyDaiReserves = fyDai.balanceOf(address(this));\n            daiReturned = tokensBurned.mul(daiReserves).div(supply);\n            fyDaiReturned = tokensBurned.mul(fyDaiReserves).div(supply);\n        }\n\n        _burn(from, tokensBurned);\n        dai.transfer(to, daiReturned);\n        fyDai.transfer(to, fyDaiReturned);\n        emit Liquidity(maturity, from, to, toInt256(daiReturned), toInt256(fyDaiReturned), -toInt256(tokensBurned));\n\n        return (daiReturned, fyDaiReturned);\n    }\n\n    /// @dev Sell Dai for fyDai\n    /// The trader needs to have called `dai.approve`\n    /// @param from Wallet providing the dai being sold. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the fyDai being bought\n    /// @param daiIn Amount of dai being sold that will be taken from the user's wallet\n    /// @return Amount of fyDai that will be deposited on `to` wallet\n    function sellDai(address from, address to, uint128 daiIn)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns(uint128)\n    {\n        uint128 fyDaiOut = sellDaiPreview(daiIn);\n\n        dai.transferFrom(from, address(this), daiIn);\n        fyDai.transfer(to, fyDaiOut);\n        emit Trade(maturity, from, to, -toInt256(daiIn), toInt256(fyDaiOut));\n\n        return fyDaiOut;\n    }\n\n    /// @dev Returns how much fyDai would be obtained by selling `daiIn` dai\n    /// @param daiIn Amount of dai hypothetically sold.\n    /// @return Amount of fyDai hypothetically bought.\n    function sellDaiPreview(uint128 daiIn)\n        public view override\n        beforeMaturity\n        returns(uint128)\n    {\n        uint128 daiReserves = getDaiReserves();\n        uint128 fyDaiReserves = getFYDaiReserves();\n\n        uint128 fyDaiOut = YieldMath.fyDaiOutForDaiIn(\n            daiReserves,\n            fyDaiReserves,\n            daiIn,\n            toUint128(maturity - now), // This can't be called after maturity\n            k,\n            g1\n        );\n\n        require(\n            sub(fyDaiReserves, fyDaiOut) >= add(daiReserves, daiIn),\n            \"Pool: fyDai reserves too low\"\n        );\n\n        return fyDaiOut;\n    }\n\n    /// @dev Buy Dai for fyDai\n    /// The trader needs to have called `fyDai.approve`\n    /// @param from Wallet providing the fyDai being sold. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the dai being bought\n    /// @param daiOut Amount of dai being bought that will be deposited in `to` wallet\n    /// @return Amount of fyDai that will be taken from `from` wallet\n    function buyDai(address from, address to, uint128 daiOut)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns(uint128)\n    {\n        uint128 fyDaiIn = buyDaiPreview(daiOut);\n\n        fyDai.transferFrom(from, address(this), fyDaiIn);\n        dai.transfer(to, daiOut);\n        emit Trade(maturity, from, to, toInt256(daiOut), -toInt256(fyDaiIn));\n\n        return fyDaiIn;\n    }\n\n    /// @dev Returns how much fyDai would be required to buy `daiOut` dai.\n    /// @param daiOut Amount of dai hypothetically desired.\n    /// @return Amount of fyDai hypothetically required.\n    function buyDaiPreview(uint128 daiOut)\n        public view override\n        beforeMaturity\n        returns(uint128)\n    {\n        return YieldMath.fyDaiInForDaiOut(\n            getDaiReserves(),\n            getFYDaiReserves(),\n            daiOut,\n            toUint128(maturity - now), // This can't be called after maturity\n            k,\n            g2\n        );\n    }\n\n    /// @dev Sell fyDai for Dai\n    /// The trader needs to have called `fyDai.approve`\n    /// @param from Wallet providing the fyDai being sold. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the dai being bought\n    /// @param fyDaiIn Amount of fyDai being sold that will be taken from the user's wallet\n    /// @return Amount of dai that will be deposited on `to` wallet\n    function sellFYDai(address from, address to, uint128 fyDaiIn)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns(uint128)\n    {\n        uint128 daiOut = sellFYDaiPreview(fyDaiIn);\n\n        fyDai.transferFrom(from, address(this), fyDaiIn);\n        dai.transfer(to, daiOut);\n        emit Trade(maturity, from, to, toInt256(daiOut), -toInt256(fyDaiIn));\n\n        return daiOut;\n    }\n\n    /// @dev Returns how much dai would be obtained by selling `fyDaiIn` fyDai.\n    /// @param fyDaiIn Amount of fyDai hypothetically sold.\n    /// @return Amount of Dai hypothetically bought.\n    function sellFYDaiPreview(uint128 fyDaiIn)\n        public view override\n        beforeMaturity\n        returns(uint128)\n    {\n        return YieldMath.daiOutForFYDaiIn(\n            getDaiReserves(),\n            getFYDaiReserves(),\n            fyDaiIn,\n            toUint128(maturity - now), // This can't be called after maturity\n            k,\n            g2\n        );\n    }\n\n    /// @dev Buy fyDai for dai\n    /// The trader needs to have called `dai.approve`\n    /// @param from Wallet providing the dai being sold. Must have approved the operator with `pool.addDelegate(operator)`.\n    /// @param to Wallet receiving the fyDai being bought\n    /// @param fyDaiOut Amount of fyDai being bought that will be deposited in `to` wallet\n    /// @return Amount of dai that will be taken from `from` wallet\n    function buyFYDai(address from, address to, uint128 fyDaiOut)\n        external override\n        onlyHolderOrDelegate(from, \"Pool: Only Holder Or Delegate\")\n        returns(uint128)\n    {\n        uint128 daiIn = buyFYDaiPreview(fyDaiOut);\n\n        dai.transferFrom(from, address(this), daiIn);\n        fyDai.transfer(to, fyDaiOut);\n        emit Trade(maturity, from, to, -toInt256(daiIn), toInt256(fyDaiOut));\n\n        return daiIn;\n    }\n\n\n    /// @dev Returns how much dai would be required to buy `fyDaiOut` fyDai.\n    /// @param fyDaiOut Amount of fyDai hypothetically desired.\n    /// @return Amount of Dai hypothetically required.\n    function buyFYDaiPreview(uint128 fyDaiOut)\n        public view override\n        beforeMaturity\n        returns(uint128)\n    {\n        uint128 daiReserves = getDaiReserves();\n        uint128 fyDaiReserves = getFYDaiReserves();\n\n        uint128 daiIn = YieldMath.daiInForFYDaiOut(\n            daiReserves,\n            fyDaiReserves,\n            fyDaiOut,\n            toUint128(maturity - now), // This can't be called after maturity\n            k,\n            g1\n        );\n\n        require(\n            sub(fyDaiReserves, fyDaiOut) >= add(daiReserves, daiIn),\n            \"Pool: fyDai reserves too low\"\n        );\n\n        return daiIn;\n    }\n\n    /// @dev Returns the \"virtual\" fyDai reserves\n    function getFYDaiReserves()\n        public view override\n        returns(uint128)\n    {\n        return toUint128(fyDai.balanceOf(address(this)).add(totalSupply()));\n    }\n\n    /// @dev Returns the Dai reserves\n    function getDaiReserves()\n        public view override\n        returns(uint128)\n    {\n        return toUint128(dai.balanceOf(address(this)));\n    }\n}\n"
    },
    "@yield-protocol/yieldspace-v1/contracts/YieldMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.6.0;\r\n\r\nimport \"./Math64x64.sol\";\r\n\r\n/**\r\n * Ethereum smart contract library implementing Yield Math model.\r\n */\r\nlibrary YieldMath {\r\n  /**\r\n   * Calculate the amount of fyDai a user would get for given amount of Dai.\r\n   *\r\n   * @param daiReserves Dai reserves amount\r\n   * @param fyDaiReserves fyDai reserves amount\r\n   * @param daiAmount Dai amount to be traded\r\n   * @param timeTillMaturity time till maturity in seconds\r\n   * @param k time till maturity coefficient, multiplied by 2^64\r\n   * @param g fee coefficient, multiplied by 2^64\r\n   * @return the amount of fyDai a user would get for given amount of Dai\r\n   */\r\n  function fyDaiOutForDaiIn (\r\n    uint128 daiReserves, uint128 fyDaiReserves, uint128 daiAmount,\r\n    uint128 timeTillMaturity, int128 k, int128 g)\r\n  internal pure returns (uint128) {\r\n    // t = k * timeTillMaturity\r\n    int128 t = Math64x64.mul (k, Math64x64.fromUInt (timeTillMaturity));\r\n\r\n    // a = (1 - gt)\r\n    int128 a = Math64x64.sub (0x10000000000000000, Math64x64.mul (g, t));\r\n    require (a > 0, \"YieldMath: Too far from maturity\");\r\n\r\n    // xdx = daiReserves + daiAmount\r\n    uint256 xdx = uint256 (daiReserves) + uint256 (daiAmount);\r\n    require (xdx < 0x100000000000000000000000000000000, \"YieldMath: Too much Dai in\");\r\n\r\n    uint256 sum =\r\n      pow (daiReserves, uint128 (a), 0x10000000000000000) +\r\n      pow (fyDaiReserves, uint128 (a), 0x10000000000000000) -\r\n      pow (uint128(xdx), uint128 (a), 0x10000000000000000);\r\n    require (sum < 0x100000000000000000000000000000000, \"YieldMath: Insufficient fyDai reserves\");\r\n\r\n    uint256 result = fyDaiReserves - pow (uint128 (sum), 0x10000000000000000, uint128 (a));\r\n    require (result < 0x100000000000000000000000000000000, \"YieldMath: Rounding induced error\");\r\n    result = result > 1e12 ? result - 1e12 : 0; // Substract error guard, flooring the result at zero\r\n\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate the amount of Dai a user would get for certain amount of fyDai.\r\n   *\r\n   * @param daiReserves Dai reserves amount\r\n   * @param fyDaiReserves fyDai reserves amount\r\n   * @param fyDaiAmount fyDai amount to be traded\r\n   * @param timeTillMaturity time till maturity in seconds\r\n   * @param k time till maturity coefficient, multiplied by 2^64\r\n   * @param g fee coefficient, multiplied by 2^64\r\n   * @return the amount of Dai a user would get for given amount of fyDai\r\n   */\r\n  function daiOutForFYDaiIn (\r\n    uint128 daiReserves, uint128 fyDaiReserves, uint128 fyDaiAmount,\r\n    uint128 timeTillMaturity, int128 k, int128 g)\r\n  internal pure returns (uint128) {\r\n    // t = k * timeTillMaturity\r\n    int128 t = Math64x64.mul (k, Math64x64.fromUInt (timeTillMaturity));\r\n\r\n    // a = (1 - gt)\r\n    int128 a = Math64x64.sub (0x10000000000000000, Math64x64.mul (g, t));\r\n    require (a > 0, \"YieldMath: Too far from maturity\");\r\n\r\n    // ydy = fyDaiReserves + fyDaiAmount;\r\n    uint256 ydy = uint256 (fyDaiReserves) + uint256 (fyDaiAmount);\r\n    require (ydy < 0x100000000000000000000000000000000, \"YieldMath: Too much fyDai in\");\r\n\r\n    uint256 sum =\r\n      pow (uint128 (daiReserves), uint128 (a), 0x10000000000000000) -\r\n      pow (uint128 (ydy), uint128 (a), 0x10000000000000000) +\r\n      pow (fyDaiReserves, uint128 (a), 0x10000000000000000);\r\n    require (sum < 0x100000000000000000000000000000000, \"YieldMath: Insufficient Dai reserves\");\r\n\r\n    uint256 result =\r\n      daiReserves -\r\n      pow (uint128 (sum), 0x10000000000000000, uint128 (a));\r\n    require (result < 0x100000000000000000000000000000000, \"YieldMath: Rounding induced error\");\r\n    result = result > 1e12 ? result - 1e12 : 0; // Substract error guard, flooring the result at zero\r\n\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate the amount of fyDai a user could sell for given amount of Dai.\r\n   *\r\n   * @param daiReserves Dai reserves amount\r\n   * @param fyDaiReserves fyDai reserves amount\r\n   * @param daiAmount Dai amount to be traded\r\n   * @param timeTillMaturity time till maturity in seconds\r\n   * @param k time till maturity coefficient, multiplied by 2^64\r\n   * @param g fee coefficient, multiplied by 2^64\r\n   * @return the amount of fyDai a user could sell for given amount of Dai\r\n   */\r\n  function fyDaiInForDaiOut (\r\n    uint128 daiReserves, uint128 fyDaiReserves, uint128 daiAmount,\r\n    uint128 timeTillMaturity, int128 k, int128 g)\r\n  internal pure returns (uint128) {\r\n    // t = k * timeTillMaturity\r\n    int128 t = Math64x64.mul (k, Math64x64.fromUInt (timeTillMaturity));\r\n\r\n    // a = (1 - gt)\r\n    int128 a = Math64x64.sub (0x10000000000000000, Math64x64.mul (g, t));\r\n    require (a > 0, \"YieldMath: Too far from maturity\");\r\n\r\n    // xdx = daiReserves - daiAmount\r\n    uint256 xdx = uint256 (daiReserves) - uint256 (daiAmount);\r\n    require (xdx < 0x100000000000000000000000000000000, \"YieldMath: Too much Dai out\");\r\n\r\n    uint256 sum =\r\n      pow (uint128 (daiReserves), uint128 (a), 0x10000000000000000) +\r\n      pow (fyDaiReserves, uint128 (a), 0x10000000000000000) -\r\n      pow (uint128 (xdx), uint128 (a), 0x10000000000000000);\r\n    require (sum < 0x100000000000000000000000000000000, \"YieldMath: Resulting fyDai reserves too high\");\r\n\r\n    uint256 result = pow (uint128 (sum), 0x10000000000000000, uint128 (a)) - fyDaiReserves;\r\n    require (result < 0x100000000000000000000000000000000, \"YieldMath: Rounding induced error\");\r\n    result = result < type(uint128).max - 1e12 ? result + 1e12 : type(uint128).max; // Add error guard, ceiling the result at max\r\n\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate the amount of Dai a user would have to pay for certain amount of\r\n   * fyDai.\r\n   *\r\n   * @param daiReserves Dai reserves amount\r\n   * @param fyDaiReserves fyDai reserves amount\r\n   * @param fyDaiAmount fyDai amount to be traded\r\n   * @param timeTillMaturity time till maturity in seconds\r\n   * @param k time till maturity coefficient, multiplied by 2^64\r\n   * @param g fee coefficient, multiplied by 2^64\r\n   * @return the amount of Dai a user would have to pay for given amount of\r\n   *         fyDai\r\n   */\r\n  function daiInForFYDaiOut (\r\n    uint128 daiReserves, uint128 fyDaiReserves, uint128 fyDaiAmount,\r\n    uint128 timeTillMaturity, int128 k, int128 g)\r\n  internal pure returns (uint128) {\r\n    // a = (1 - g * k * timeTillMaturity)\r\n    int128 a = Math64x64.sub (0x10000000000000000, Math64x64.mul (g, Math64x64.mul (k, Math64x64.fromUInt (timeTillMaturity))));\r\n    require (a > 0, \"YieldMath: Too far from maturity\");\r\n\r\n    // ydy = fyDaiReserves - fyDaiAmount;\r\n    uint256 ydy = uint256 (fyDaiReserves) - uint256 (fyDaiAmount);\r\n    require (ydy < 0x100000000000000000000000000000000, \"YieldMath: Too much fyDai out\");\r\n\r\n    uint256 sum =\r\n      pow (daiReserves, uint128 (a), 0x10000000000000000) +\r\n      pow (fyDaiReserves, uint128 (a), 0x10000000000000000) -\r\n      pow (uint128 (ydy), uint128 (a), 0x10000000000000000);\r\n    require (sum < 0x100000000000000000000000000000000, \"YieldMath: Resulting Dai reserves too high\");\r\n\r\n    uint256 result =\r\n      pow (uint128 (sum), 0x10000000000000000, uint128 (a)) -\r\n      daiReserves;\r\n    require (result < 0x100000000000000000000000000000000, \"YieldMath: Rounding induced error\");\r\n    result = result < type(uint128).max - 1e12 ? result + 1e12 : type(uint128).max; // Add error guard, ceiling the result at max\r\n    \r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Raise given number x into power specified as a simple fraction y/z and then\r\n   * multiply the result by the normalization factor 2^(128 * (1 - y/z)).\r\n   * Revert if z is zero, or if both x and y are zeros.\r\n   *\r\n   * @param x number to raise into given power y/z\r\n   * @param y numerator of the power to raise x into\r\n   * @param z denominator of the power to raise x into\r\n   * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))\r\n   */\r\n  function pow (uint128 x, uint128 y, uint128 z)\r\n  internal pure returns (uint256) {\r\n    require (z != 0);\r\n\r\n    if (x == 0) {\r\n      require (y != 0);\r\n      return 0;\r\n    } else {\r\n      uint256 l =\r\n        uint256 (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2 (x)) * y / z;\r\n      if (l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;\r\n      else return uint256 (pow_2 (uint128 (0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert\r\n   * in case x is zero.\r\n   *\r\n   * @param x number to calculate base 2 logarithm of\r\n   * @return base 2 logarithm of x, multiplied by 2^121\r\n   */\r\n  function log_2 (uint128 x)\r\n  internal pure returns (uint128) {\r\n    require (x != 0);\r\n\r\n    uint b = x;\r\n\r\n    uint l = 0xFE000000000000000000000000000000;\r\n\r\n    if (b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\r\n    if (b < 0x1000000000000000000000000) {l -= 0x40000000000000000000000000000000; b <<= 32;}\r\n    if (b < 0x10000000000000000000000000000) {l -= 0x20000000000000000000000000000000; b <<= 16;}\r\n    if (b < 0x1000000000000000000000000000000) {l -= 0x10000000000000000000000000000000; b <<= 8;}\r\n    if (b < 0x10000000000000000000000000000000) {l -= 0x8000000000000000000000000000000; b <<= 4;}\r\n    if (b < 0x40000000000000000000000000000000) {l -= 0x4000000000000000000000000000000; b <<= 2;}\r\n    if (b < 0x80000000000000000000000000000000) {l -= 0x2000000000000000000000000000000; b <<= 1;}\r\n\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000000;}\r\n    /* Precision reduced to 64 bits\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\r\n    b = b * b >> 127; if (b >= 0x100000000000000000000000000000000) l |= 0x1;\r\n    */\r\n\r\n    return uint128 (l);\r\n  }\r\n\r\n  /**\r\n   * Calculate 2 raised into given power.\r\n   *\r\n   * @param x power to raise 2 into, multiplied by 2^121\r\n   * @return 2 raised into given power\r\n   */\r\n  function pow_2 (uint128 x)\r\n  internal pure returns (uint128) {\r\n    uint r = 0x80000000000000000000000000000000;\r\n    if (x & 0x1000000000000000000000000000000 > 0) r = r * 0xb504f333f9de6484597d89b3754abe9f >> 127;\r\n    if (x & 0x800000000000000000000000000000 > 0) r = r * 0x9837f0518db8a96f46ad23182e42f6f6 >> 127;\r\n    if (x & 0x400000000000000000000000000000 > 0) r = r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90 >> 127;\r\n    if (x & 0x200000000000000000000000000000 > 0) r = r * 0x85aac367cc487b14c5c95b8c2154c1b2 >> 127;\r\n    if (x & 0x100000000000000000000000000000 > 0) r = r * 0x82cd8698ac2ba1d73e2a475b46520bff >> 127;\r\n    if (x & 0x80000000000000000000000000000 > 0) r = r * 0x8164d1f3bc0307737be56527bd14def4 >> 127;\r\n    if (x & 0x40000000000000000000000000000 > 0) r = r * 0x80b1ed4fd999ab6c25335719b6e6fd20 >> 127;\r\n    if (x & 0x20000000000000000000000000000 > 0) r = r * 0x8058d7d2d5e5f6b094d589f608ee4aa2 >> 127;\r\n    if (x & 0x10000000000000000000000000000 > 0) r = r * 0x802c6436d0e04f50ff8ce94a6797b3ce >> 127;\r\n    if (x & 0x8000000000000000000000000000 > 0) r = r * 0x8016302f174676283690dfe44d11d008 >> 127;\r\n    if (x & 0x4000000000000000000000000000 > 0) r = r * 0x800b179c82028fd0945e54e2ae18f2f0 >> 127;\r\n    if (x & 0x2000000000000000000000000000 > 0) r = r * 0x80058baf7fee3b5d1c718b38e549cb93 >> 127;\r\n    if (x & 0x1000000000000000000000000000 > 0) r = r * 0x8002c5d00fdcfcb6b6566a58c048be1f >> 127;\r\n    if (x & 0x800000000000000000000000000 > 0) r = r * 0x800162e61bed4a48e84c2e1a463473d9 >> 127;\r\n    if (x & 0x400000000000000000000000000 > 0) r = r * 0x8000b17292f702a3aa22beacca949013 >> 127;\r\n    if (x & 0x200000000000000000000000000 > 0) r = r * 0x800058b92abbae02030c5fa5256f41fe >> 127;\r\n    if (x & 0x100000000000000000000000000 > 0) r = r * 0x80002c5c8dade4d71776c0f4dbea67d6 >> 127;\r\n    if (x & 0x80000000000000000000000000 > 0) r = r * 0x8000162e44eaf636526be456600bdbe4 >> 127;\r\n    if (x & 0x40000000000000000000000000 > 0) r = r * 0x80000b1721fa7c188307016c1cd4e8b6 >> 127;\r\n    if (x & 0x20000000000000000000000000 > 0) r = r * 0x8000058b90de7e4cecfc487503488bb1 >> 127;\r\n    if (x & 0x10000000000000000000000000 > 0) r = r * 0x800002c5c8678f36cbfce50a6de60b14 >> 127;\r\n    if (x & 0x8000000000000000000000000 > 0) r = r * 0x80000162e431db9f80b2347b5d62e516 >> 127;\r\n    if (x & 0x4000000000000000000000000 > 0) r = r * 0x800000b1721872d0c7b08cf1e0114152 >> 127;\r\n    if (x & 0x2000000000000000000000000 > 0) r = r * 0x80000058b90c1aa8a5c3736cb77e8dff >> 127;\r\n    if (x & 0x1000000000000000000000000 > 0) r = r * 0x8000002c5c8605a4635f2efc2362d978 >> 127;\r\n    if (x & 0x800000000000000000000000 > 0) r = r * 0x800000162e4300e635cf4a109e3939bd >> 127;\r\n    if (x & 0x400000000000000000000000 > 0) r = r * 0x8000000b17217ff81bef9c551590cf83 >> 127;\r\n    if (x & 0x200000000000000000000000 > 0) r = r * 0x800000058b90bfdd4e39cd52c0cfa27c >> 127;\r\n    if (x & 0x100000000000000000000000 > 0) r = r * 0x80000002c5c85fe6f72d669e0e76e411 >> 127;\r\n    if (x & 0x80000000000000000000000 > 0) r = r * 0x8000000162e42ff18f9ad35186d0df28 >> 127;\r\n    if (x & 0x40000000000000000000000 > 0) r = r * 0x80000000b17217f84cce71aa0dcfffe7 >> 127;\r\n    if (x & 0x20000000000000000000000 > 0) r = r * 0x8000000058b90bfc07a77ad56ed22aaa >> 127;\r\n    if (x & 0x10000000000000000000000 > 0) r = r * 0x800000002c5c85fdfc23cdead40da8d6 >> 127;\r\n    if (x & 0x8000000000000000000000 > 0) r = r * 0x80000000162e42fefc25eb1571853a66 >> 127;\r\n    if (x & 0x4000000000000000000000 > 0) r = r * 0x800000000b17217f7d97f692baacded5 >> 127;\r\n    if (x & 0x2000000000000000000000 > 0) r = r * 0x80000000058b90bfbead3b8b5dd254d7 >> 127;\r\n    if (x & 0x1000000000000000000000 > 0) r = r * 0x8000000002c5c85fdf4eedd62f084e67 >> 127;\r\n    if (x & 0x800000000000000000000 > 0) r = r * 0x800000000162e42fefa58aef378bf586 >> 127;\r\n    if (x & 0x400000000000000000000 > 0) r = r * 0x8000000000b17217f7d24a78a3c7ef02 >> 127;\r\n    if (x & 0x200000000000000000000 > 0) r = r * 0x800000000058b90bfbe9067c93e474a6 >> 127;\r\n    if (x & 0x100000000000000000000 > 0) r = r * 0x80000000002c5c85fdf47b8e5a72599f >> 127;\r\n    if (x & 0x80000000000000000000 > 0) r = r * 0x8000000000162e42fefa3bdb315934a2 >> 127;\r\n    if (x & 0x40000000000000000000 > 0) r = r * 0x80000000000b17217f7d1d7299b49c46 >> 127;\r\n    if (x & 0x20000000000000000000 > 0) r = r * 0x8000000000058b90bfbe8e9a8d1c4ea0 >> 127;\r\n    if (x & 0x10000000000000000000 > 0) r = r * 0x800000000002c5c85fdf4745969ea76f >> 127;\r\n    if (x & 0x8000000000000000000 > 0) r = r * 0x80000000000162e42fefa3a0df5373bf >> 127;\r\n    if (x & 0x4000000000000000000 > 0) r = r * 0x800000000000b17217f7d1cff4aac1e1 >> 127;\r\n    if (x & 0x2000000000000000000 > 0) r = r * 0x80000000000058b90bfbe8e7db95a2f1 >> 127;\r\n    if (x & 0x1000000000000000000 > 0) r = r * 0x8000000000002c5c85fdf473e61ae1f8 >> 127;\r\n    if (x & 0x800000000000000000 > 0) r = r * 0x800000000000162e42fefa39f121751c >> 127;\r\n    if (x & 0x400000000000000000 > 0) r = r * 0x8000000000000b17217f7d1cf815bb96 >> 127;\r\n    if (x & 0x200000000000000000 > 0) r = r * 0x800000000000058b90bfbe8e7bec1e0d >> 127;\r\n    if (x & 0x100000000000000000 > 0) r = r * 0x80000000000002c5c85fdf473dee5f17 >> 127;\r\n    if (x & 0x80000000000000000 > 0) r = r * 0x8000000000000162e42fefa39ef5438f >> 127;\r\n    if (x & 0x40000000000000000 > 0) r = r * 0x80000000000000b17217f7d1cf7a26c8 >> 127;\r\n    if (x & 0x20000000000000000 > 0) r = r * 0x8000000000000058b90bfbe8e7bcf4a4 >> 127;\r\n    if (x & 0x10000000000000000 > 0) r = r * 0x800000000000002c5c85fdf473de72a2 >> 127;\r\n    /* Precision reduced to 64 bits\r\n    if (x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\r\n    if (x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\r\n    if (x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\r\n    if (x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\r\n    if (x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\r\n    if (x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\r\n    if (x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\r\n    if (x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\r\n    if (x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\r\n    if (x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\r\n    if (x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\r\n    if (x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\r\n    if (x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\r\n    if (x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\r\n    if (x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\r\n    if (x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\r\n    if (x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\r\n    if (x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\r\n    if (x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\r\n    if (x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\r\n    if (x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\r\n    if (x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\r\n    if (x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\r\n    if (x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\r\n    if (x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\r\n    if (x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\r\n    if (x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\r\n    if (x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\r\n    if (x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\r\n    if (x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\r\n    if (x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\r\n    if (x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\r\n    if (x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\r\n    if (x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\r\n    if (x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\r\n    if (x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\r\n    if (x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\r\n    if (x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\r\n    if (x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\r\n    if (x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\r\n    if (x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\r\n    if (x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\r\n    if (x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\r\n    if (x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\r\n    if (x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\r\n    if (x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\r\n    if (x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\r\n    if (x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\r\n    if (x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\r\n    if (x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\r\n    if (x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\r\n    if (x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\r\n    if (x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\r\n    if (x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\r\n    if (x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\r\n    if (x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\r\n    if (x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\r\n    if (x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\r\n    if (x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\r\n    if (x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\r\n    if (x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\r\n    if (x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\r\n    if (x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\r\n    if (x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127;\r\n    */\r\n\r\n    r >>= 127 - (x >> 121);\r\n\r\n    return uint128 (r);\r\n  }\r\n}"
    },
    "@yield-protocol/yieldspace-v1/contracts/Math64x64.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n/*\r\n *  Math 64.64 Smart Contract Library.  Copyright  2019 by  Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary Math64x64 {\r\n  /**\r\n   * @dev Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * @dev Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * @dev Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * @dev Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * @dev Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x <= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x << 64);\r\n  }\r\n\r\n  /**\r\n   * @dev Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x >= 0);\r\n    return uint64 (x >> 64);\r\n  }\r\n\r\n  /**\r\n   * @dev Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) << 64;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y >> 64;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n        y <= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y << 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x < 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y < 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult <=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult <=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x >= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n    uint256 hi = uint256 (x) * (y >> 128);\r\n\r\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi <<= 64;\r\n\r\n    require (hi <=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) << 64) / y;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x < 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y < 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result <= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x < 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result >= MIN_64x64 && result <= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) >> 1);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m >= 0);\r\n    require (m <\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x >= 0) {\r\n      absoluteResult = powu (uint256 (x) << 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\r\n      negativeResult = y & 1 > 0;\r\n    }\r\n\r\n    absoluteResult >>= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult <= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x >= 0);\r\n    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate binary logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 << 64;\r\n    uint256 ux = uint256 (x) << 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux >> 255;\r\n      ux >>= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate natural logarithm of x.  Revert if x <= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x > 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x & 0x8000000000000000 > 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n    if (x & 0x4000000000000000 > 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n    if (x & 0x2000000000000000 > 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n    if (x & 0x1000000000000000 > 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n    if (x & 0x800000000000000 > 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n    if (x & 0x400000000000000 > 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n    if (x & 0x200000000000000 > 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n    if (x & 0x100000000000000 > 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n    if (x & 0x80000000000000 > 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n    if (x & 0x40000000000000 > 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n    if (x & 0x20000000000000 > 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n    if (x & 0x10000000000000 > 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n    if (x & 0x8000000000000 > 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n    if (x & 0x4000000000000 > 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n    if (x & 0x2000000000000 > 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n    if (x & 0x1000000000000 > 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n    if (x & 0x800000000000 > 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n    if (x & 0x400000000000 > 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n    if (x & 0x200000000000 > 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n    if (x & 0x100000000000 > 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n    if (x & 0x80000000000 > 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n    if (x & 0x40000000000 > 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n    if (x & 0x20000000000 > 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n    if (x & 0x10000000000 > 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n    if (x & 0x8000000000 > 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n    if (x & 0x4000000000 > 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n    if (x & 0x2000000000 > 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n    if (x & 0x1000000000 > 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n    if (x & 0x800000000 > 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n    if (x & 0x400000000 > 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n    if (x & 0x200000000 > 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n    if (x & 0x100000000 > 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n    if (x & 0x80000000 > 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n    if (x & 0x40000000 > 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n    if (x & 0x20000000 > 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n    if (x & 0x10000000 > 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n    if (x & 0x8000000 > 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n    if (x & 0x4000000 > 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n    if (x & 0x2000000 > 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n    if (x & 0x1000000 > 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n    if (x & 0x800000 > 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n    if (x & 0x400000 > 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n    if (x & 0x200000 > 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n    if (x & 0x100000 > 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n    if (x & 0x80000 > 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n    if (x & 0x40000 > 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n    if (x & 0x20000 > 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n    if (x & 0x10000 > 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n    if (x & 0x8000 > 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n    if (x & 0x4000 > 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n    if (x & 0x2000 > 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n    if (x & 0x1000 > 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n    if (x & 0x800 > 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n    if (x & 0x400 > 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n    if (x & 0x200 > 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n    if (x & 0x100 > 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n    if (x & 0x80 > 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n    if (x & 0x40 > 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n    if (x & 0x20 > 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n    if (x & 0x10 > 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n    if (x & 0x8 > 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n    if (x & 0x4 > 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n    if (x & 0x2 > 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n    if (x & 0x1 > 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n\r\n    result >>= 63 - (x >> 64);\r\n    require (result <= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x < 0x400000000000000000); // Overflow\r\n\r\n    if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x << 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x >> 192;\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y >> 128);\r\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x >> 192;\r\n      uint256 xl = x << 64;\r\n\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi << 128;\r\n      if (xl < lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi >> 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\r\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\r\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\r\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\r\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\r\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\r\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\r\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe > 0) x >>= xe;\r\n      else x <<= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y > 0) {\r\n        if (y & 1 > 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result >>= 128;\r\n            re += 1;\r\n          } else result >>= 127;\r\n          if (re < -127) return 0; // Underflow\r\n          require (re < 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y >>= 1;\r\n          xe <<= 1;\r\n          if (x >=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x >>= 128;\r\n            xe += 1;\r\n          } else x >>= 127;\r\n          if (xe < -127) return 0; // Underflow\r\n          require (xe < 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re > 0) result <<= re;\r\n      else if (re < 0) result >>= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r > 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 >> 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "@yield-protocol/vault-v1/contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@yield-protocol/utils/contracts/math/DecimalMath.sol\";\nimport \"@yield-protocol/utils/contracts/access/Orchestrated.sol\";\nimport \"dss-interfaces/src/dss/VatAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"dss-interfaces/src/dss/DaiJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/GemJoinAbstract.sol\";\nimport \"dss-interfaces/src/dss/PotAbstract.sol\";\nimport \"@yield-protocol/utils/contracts/interfaces/chai/IChai.sol\";\nimport \"./interfaces/ITreasury.sol\";\n\n\n/**\n * @dev Treasury manages asset transfers between all contracts in the Yield Protocol and other external contracts such as Chai and MakerDAO.\n * Treasury doesn't have any transactional functions available for regular users.\n * All transactional methods are to be available only for orchestrated contracts.\n * Treasury will ensure that all Weth is always stored as collateral in MAkerDAO.\n * Treasury will use all Dai to pay off system debt in MakerDAO first, and if there is no system debt the surplus Dai will be wrapped as Chai.\n * Treasury will use any Chai it holds when requested to provide Dai. If there isn't enough Chai, it will borrow Dai from MakerDAO.\n */\ncontract Treasury is ITreasury, Orchestrated(), DecimalMath {\n    bytes32 constant WETH = \"ETH-A\";\n\n    VatAbstract public override vat;\n    IWeth public override weth;\n    DaiAbstract public override dai;\n    DaiJoinAbstract public override daiJoin;\n    GemJoinAbstract public override wethJoin;\n    PotAbstract public override pot;\n    IChai public override chai;\n    address public unwind;\n\n    bool public override live = true;\n\n    /// @dev As part of the constructor:\n    /// Treasury allows the `chai` and `wethJoin` contracts to take as many tokens as wanted.\n    /// Treasury approves the `daiJoin` and `wethJoin` contracts to move assets in MakerDAO.\n    constructor (\n        address vat_,\n        address weth_,\n        address dai_,\n        address wethJoin_,\n        address daiJoin_,\n        address pot_,\n        address chai_\n    ) public {\n        // These could be hardcoded for mainnet deployment.\n        dai = DaiAbstract(dai_);\n        chai = IChai(chai_);\n        pot = PotAbstract(pot_);\n        weth = IWeth(weth_);\n        daiJoin = DaiJoinAbstract(daiJoin_);\n        wethJoin = GemJoinAbstract(wethJoin_);\n        vat = VatAbstract(vat_);\n        vat.hope(wethJoin_);\n        vat.hope(daiJoin_);\n\n        dai.approve(address(chai), uint256(-1));      // Chai will never cheat on us\n        dai.approve(address(daiJoin), uint256(-1));   // DaiJoin will never cheat on us\n        weth.approve(address(wethJoin), uint256(-1)); // WethJoin will never cheat on us\n    }\n\n    /// @dev Only while the Treasury is not unwinding due to a MakerDAO shutdown.\n    modifier onlyLive() {\n        require(live == true, \"Treasury: Not available during unwind\");\n        _;\n    }\n\n    /// @dev Safe casting from uint256 to int256\n    function toInt(uint256 x) internal pure returns(int256) {\n        require(\n            x <= uint256(type(int256).max),\n            \"Treasury: Cast overflow\"\n        );\n        return int256(x);\n    }\n\n    /// @dev Disables pulling and pushing. Can only be called if MakerDAO shuts down.\n    function shutdown() public override {\n        require(\n            vat.live() == 0,\n            \"Treasury: MakerDAO is live\"\n        );\n        live = false;\n    }\n\n    /// @dev Returns the Treasury debt towards MakerDAO, in Dai.\n    /// We have borrowed (rate * art)\n    /// Borrowing limit (rate * art) <= (ink * spot)\n    function debt() public view override returns(uint256) {\n        (, uint256 rate,,,) = vat.ilks(WETH);            // Retrieve the MakerDAO stability fee for Weth\n        (, uint256 art) = vat.urns(WETH, address(this)); // Retrieve the Treasury debt in MakerDAO\n        return muld(art, rate);\n    }\n\n    /// @dev Returns the amount of chai in this contract, converted to Dai.\n    function savings() public view override returns(uint256){\n        return muld(chai.balanceOf(address(this)), pot.chi());\n    }\n\n    /// @dev Takes dai from user and pays as much system debt as possible, saving the rest as chai.\n    /// User needs to have approved Treasury to take the Dai.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to take Dai from.\n    /// @param daiAmount Dai quantity to take.\n    function pushDai(address from, uint256 daiAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        require(dai.transferFrom(from, address(this), daiAmount));  // Take dai from user to Treasury\n\n        // Due to the DSR being mostly lower than the SF, it is better for us to\n        // immediately pay back as much as possible from the current debt to\n        // minimize our future stability fee liabilities. If we didn't do this,\n        // the treasury would simultaneously owe DAI (and need to pay the SF) and\n        // hold Chai, which is inefficient.\n        uint256 toRepay = Math.min(debt(), daiAmount);\n        if (toRepay > 0) {\n            daiJoin.join(address(this), toRepay);\n            // Remove debt from vault using frob\n            (, uint256 rate,,,) = vat.ilks(WETH); // Retrieve the MakerDAO stability fee\n            vat.frob(\n                WETH,\n                address(this),\n                address(this),\n                address(this),\n                0,                           // Weth collateral to add\n                -toInt(divd(toRepay, rate))  // Dai debt to remove\n            );\n        }\n\n        uint256 toSave = daiAmount - toRepay;         // toRepay can't be greater than dai\n        if (toSave > 0) {\n            chai.join(address(this), toSave);    // Give dai to Chai, take chai back\n        }\n    }\n\n    /// @dev Takes Chai from user and pays as much system debt as possible, saving the rest as chai.\n    /// User needs to have approved Treasury to take the Chai.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to take Chai from.\n    /// @param chaiAmount Chai quantity to take.\n    function pushChai(address from, uint256 chaiAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        require(chai.transferFrom(from, address(this), chaiAmount));\n        uint256 daiAmount = chai.dai(address(this));\n\n        uint256 toRepay = Math.min(debt(), daiAmount);\n        if (toRepay > 0) {\n            chai.draw(address(this), toRepay);     // Grab dai from Chai, converted from chai\n            daiJoin.join(address(this), toRepay);\n            // Remove debt from vault using frob\n            (, uint256 rate,,,) = vat.ilks(WETH); // Retrieve the MakerDAO stability fee\n            vat.frob(\n                WETH,\n                address(this),\n                address(this),\n                address(this),\n                0,                           // Weth collateral to add\n                -toInt(divd(toRepay, rate))  // Dai debt to remove\n            );\n        }\n        // Anything that is left from repaying, is chai savings\n    }\n\n    /// @dev Takes Weth collateral from user into the Treasury Maker vault\n    /// User needs to have approved Treasury to take the Weth.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to take Weth from.\n    /// @param wethAmount Weth quantity to take.\n    function pushWeth(address from, uint256 wethAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        require(weth.transferFrom(from, address(this), wethAmount));\n\n        wethJoin.join(address(this), wethAmount); // GemJoin reverts if anything goes wrong.\n        // All added collateral should be locked into the vault using frob\n        vat.frob(\n            WETH,\n            address(this),\n            address(this),\n            address(this),\n            toInt(wethAmount), // Collateral to add - WAD\n            0 // Normalized Dai to receive - WAD\n        );\n    }\n\n    /// @dev Returns dai using chai savings as much as possible, and borrowing the rest.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to send Dai to.\n    /// @param daiAmount Dai quantity to send.\n    function pullDai(address to, uint256 daiAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        uint256 toRelease = Math.min(savings(), daiAmount);\n        if (toRelease > 0) {\n            chai.draw(address(this), toRelease);     // Grab dai from Chai, converted from chai\n        }\n\n        uint256 toBorrow = daiAmount - toRelease;    // toRelease can't be greater than dai\n        if (toBorrow > 0) {\n            (, uint256 rate,,,) = vat.ilks(WETH); // Retrieve the MakerDAO stability fee\n            // Increase the dai debt by the dai to receive divided by the stability fee\n            // `frob` deals with \"normalized debt\", instead of DAI.\n            // \"normalized debt\" is used to account for the fact that debt grows\n            // by the stability fee. The stability fee is accumulated by the \"rate\"\n            // variable, so if you store Dai balances in \"normalized dai\" you can\n            // deal with the stability fee accumulation with just a multiplication.\n            // This means that the `frob` call needs to be divided by the `rate`\n            // while the `GemJoin.exit` call can be done with the raw `toBorrow`\n            // number.\n            vat.frob(\n                WETH,\n                address(this),\n                address(this),\n                address(this),\n                0,\n                toInt(divdrup(toBorrow, rate))      // We need to round up, otherwise we won't exit toBorrow\n            );\n            daiJoin.exit(address(this), toBorrow); // `daiJoin` reverts on failures\n        }\n\n        dai.transfer(to, daiAmount);               // Give dai to user - Dai doesn't have a return value for `transfer`\n    }\n\n    /// @dev Returns chai using chai savings as much as possible, and borrowing the rest.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to send Chai to.\n    /// @param chaiAmount Chai quantity to send.\n    function pullChai(address to, uint256 chaiAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        uint256 chi = pot.chi();\n        uint256 daiAmount = muldrup(chaiAmount, chi);   // dai = price * chai, we round up, otherwise we won't borrow enough dai\n        uint256 toRelease = Math.min(savings(), daiAmount);\n        // As much chai as the Treasury has, can be used, we borrow dai and convert it to chai for the rest\n\n        uint256 toBorrow = daiAmount - toRelease;    // toRelease can't be greater than daiAmount\n        if (toBorrow > 0) {\n            (, uint256 rate,,,) = vat.ilks(WETH); // Retrieve the MakerDAO stability fee\n            // Increase the dai debt by the dai to receive divided by the stability fee\n            vat.frob(\n                WETH,\n                address(this),\n                address(this),\n                address(this),\n                0,\n                toInt(divdrup(toBorrow, rate))       // We need to round up, otherwise we won't exit toBorrow\n            ); // `vat.frob` reverts on failure\n            daiJoin.exit(address(this), toBorrow);  // `daiJoin` reverts on failures\n            chai.join(address(this), toBorrow);     // Grab chai from Chai, converted from dai\n        }\n\n        require(chai.transfer(to, chaiAmount));                            // Give dai to user\n    }\n\n    /// @dev Moves Weth collateral from Treasury controlled Maker Eth vault to `to` address.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to send Weth to.\n    /// @param wethAmount Weth quantity to send.\n    function pullWeth(address to, uint256 wethAmount)\n        public override\n        onlyOrchestrated(\"Treasury: Not Authorized\")\n        onlyLive\n    {\n        // Remove collateral from vault using frob\n        vat.frob(\n            WETH,\n            address(this),\n            address(this),\n            address(this),\n            -toInt(wethAmount), // Weth collateral to remove - WAD\n            0              // Dai debt to add - WAD\n        );\n        wethJoin.exit(to, wethAmount); // `GemJoin` reverts on failures\n    }\n\n    /// @dev Registers the one contract that will take assets from the Treasury if MakerDAO shuts down.\n    /// This function can only be called by the contract owner, which should only be possible during deployment.\n    /// This function allows Unwind to take all the Chai savings and operate with the Treasury MakerDAO vault.\n    /// @param unwind_ The address of the Unwild.sol contract.\n    function registerUnwind(address unwind_)\n        public\n        onlyOwner\n    {\n        require(\n            unwind == address(0),\n            \"Treasury: Unwind already set\"\n        );\n        unwind = unwind_;\n        chai.approve(address(unwind), uint256(-1)); // Unwind will never cheat on us\n        vat.hope(address(unwind));                  // Unwind will never cheat on us\n    }\n}\n"
    },
    "contracts/mocks/Fixtures.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\n// Trick the compiler to create all these aretifacts for the tests\n\nimport \"@yield-protocol/yieldspace-v1/contracts/Pool.sol\";\nimport \"@yield-protocol/vault-v1/contracts/Treasury.sol\";\nimport \"@yield-protocol/vault-v1/contracts/FYDai.sol\";\nimport \"@yield-protocol/vault-v1/contracts/Controller.sol\";\nimport \"@yield-protocol/vault-v1/contracts/Liquidations.sol\";\nimport \"@yield-protocol/vault-v1/contracts/Unwind.sol\";"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\n\nimport \"@yield-protocol/utils/contracts/token/ERC20Permit.sol\";\n\n\ncontract ERC20Mock is ERC20Permit {\n    constructor () public ERC20Permit(\"Test\", \"TST\") {\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public {\n        _burn(from, amount);\n    }\n}\n"
    },
    "contracts/mocks/DssPsmMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.7;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./DaiJoinMock.sol\";\nimport \"./AuthGemJoinMock.sol\";\n\n\n// Peg Stability Module\n// Allows anyone to go between Dai and the Gem by pooling the liquidity\n// An optional fee is charged for incoming and outgoing transfers\n\ncontract DssPsmMock {\n\n    IERC20 public dai;\n    AuthGemJoinMock public gemJoin;\n    DaiJoinMock public daiJoin;\n\n    uint256 public tin;         // toll in [wad]\n    uint256 public tout;        // toll out [wad]\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event File(bytes32 indexed what, uint256 data);\n    event SellGem(address indexed owner, uint256 value, uint256 fee);\n    event BuyGem(address indexed owner, uint256 value, uint256 fee);\n\n    // --- Init ---\n    constructor(IERC20 gem_, IERC20 dai_) public {\n        gemJoin = new AuthGemJoinMock(address(gem_));\n        daiJoin = new DaiJoinMock(address(dai_));\n        dai = dai_;\n        dai.approve(address(daiJoin), uint256(-1));\n    }\n\n    // --- Math ---\n    uint256 constant WAD = 10 ** 18;\n    uint256 constant RAY = 10 ** 27;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function setTin(uint256 tin_) external {\n        tin = tin_;\n    }\n    function setTout(uint256 tout_) external {\n        tout = tout_;\n    }\n\n    // --- Primary Functions ---\n    function sellGem(address usr, uint256 gemAmt) external {\n        uint256 fee = mul(gemAmt, tin) / WAD;\n        uint256 daiAmt = sub(gemAmt, fee) * 1e12; // USDC has 6 decimals, Dai 18.\n        gemJoin.join(address(this), gemAmt, msg.sender);\n        daiJoin.exit(usr, daiAmt);\n\n        emit SellGem(usr, gemAmt, fee);\n    }\n\n    function buyGem(address usr, uint256 gemAmt) external {\n        uint256 fee = mul(gemAmt, tout) / WAD;\n        uint256 daiAmt = add(gemAmt, fee) * 1e12; // USDC has 6 decimals, Dai 18.\n        require(dai.transferFrom(msg.sender, address(this), daiAmt), \"DssPsm/failed-transfer\");\n        daiJoin.join(address(this), daiAmt);\n        gemJoin.exit(usr, gemAmt);\n\n        emit BuyGem(usr, gemAmt, fee);\n    }\n}"
    },
    "contracts/mocks/DaiJoinMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.7;\nimport \"./IERC20WithMint.sol\";\n\n\ncontract DaiJoinMock {\n    IERC20WithMint public dai;  // Stablecoin Token\n\n    constructor(address dai_) public {\n        dai = IERC20WithMint(dai_);\n    }\n\n    function join(address, uint wad) external {\n        dai.burn(msg.sender, wad);\n    }\n\n    function exit(address usr, uint wad) external {\n        dai.mint(usr, wad);\n    }\n}"
    },
    "contracts/mocks/AuthGemJoinMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.7;\nimport \"./IERC20WithMint.sol\";\n\n\ncontract AuthGemJoinMock {\n\n    IERC20WithMint public gem;\n\n    constructor(address gem_) public {\n        gem = IERC20WithMint(gem_);\n    }\n\n    function join(address, uint256 wad, address _msgSender) external {\n        gem.burn(_msgSender, wad);\n    }\n\n    function exit(address guy, uint256 wad) external {\n        gem.mint(guy, wad);\n    }\n}"
    },
    "contracts/mocks/IERC20WithMint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.7;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IERC20WithMint is IERC20 {\n    function mint(address, uint256) external;\n    function burn(address, uint256) external;\n}\n"
    },
    "contracts/external/weth/interfaces/IWeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.6.10;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint) external;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}